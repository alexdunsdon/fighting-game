<?xml version="1.0" encoding="utf-8"?>
<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
  <External>null</External>
  <External>nil</External>
  <Item class="Workspace" referent="RBXF4A234D3">
    <Properties>
      <string name="Name">Workspace</string>
    </Properties>
  </Item>
  <Item class="Players" referent="RBXF4A234D4">
    <Properties>
      <string name="Name">Players</string>
    </Properties>
  </Item>
  <Item class="Lighting" referent="RBXF4A234D5">
    <Properties>
      <string name="Name">Lighting</string>
    </Properties>
  </Item>
  <Item class="ReplicatedFirst" referent="RBXF4A234D6">
    <Properties>
      <string name="Name">ReplicatedFirst</string>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="RBXF4A234D7">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
      <Item class="ModuleScript" referent="RBX00000065">
        <Properties>
          <string name="Name">FightConfig</string>
          <ProtectedString name="Source"><![CDATA[--[[
	FightConfig - Shared constants for Pixel Brawl
	LOCATION: ReplicatedStorage > FightConfig (ModuleScript)
]]

local Config = {}

-- General
Config.MAX_HEALTH = 100
Config.ROUND_TIME = 60
Config.ROUNDS_TO_WIN = 2
Config.COUNTDOWN_TIME = 3
Config.ROUND_END_DELAY = 3
Config.MATCH_END_DELAY = 5

-- Movement
Config.MOVE_SPEED = 32
Config.JUMP_FORCE = 50
Config.ARENA_MIN_X = -50
Config.ARENA_MAX_X = 50
Config.GROUND_Y = 3

-- Lobby
Config.LOBBY_SPAWN = Vector3.new(0, 3, 300)
Config.ZONE_VS_BOT = Vector3.new(-30, 3, 285)
Config.ZONE_VS_FRIEND = Vector3.new(30, 3, 285)
Config.ZONE_SHOP = Vector3.new(0, 3, 265)
Config.ZONE_RADIUS = 8

-- Token rewards (bot wins only)
Config.TOKEN_REWARDS = { easy = 10, medium = 25, hard = 50 }

-- Player states
Config.PlayerStates = {
	LOBBY = "lobby",
	IN_MATCH = "inMatch",
	QUEUED = "queued",
}

-- Block
Config.BLOCK_REDUCTION = 0.25
Config.BLOCK_KNOCKBACK_MULT = 0.3

-- Attack data: { damage, range, startup, active, recovery, knockback, hitstun }
Config.Attacks = {
	punch = {
		damage = 8,
		range = 6,
		startup = 0.05,
		active = 0.07,
		recovery = 0.13,
		knockback = 6,
		hitstun = 0.2,
		isProjectile = false,
	},
	kick = {
		damage = 14,
		range = 8,
		startup = 0.1,
		active = 0.08,
		recovery = 0.2,
		knockback = 10,
		hitstun = 0.3,
		isProjectile = false,
	},
	special = {
		damage = 20,
		range = 0,
		startup = 0.2,
		active = 0,
		recovery = 0.33,
		knockback = 14,
		hitstun = 0.35,
		isProjectile = true,
		projectileSpeed = 60,
		projectileLifetime = 2,
	},
}

-- Shop abilities (purchasable combat moves)
Config.ShopAbilities = {
	dashPunch = {
		name = "Dash Punch",
		cost = 50,
		description = "Fast forward lunge + punch",
		color = Color3.fromRGB(255, 120, 40),
	},
	uppercut = {
		name = "Uppercut",
		cost = 75,
		description = "Powerful upward strike, launches enemy",
		color = Color3.fromRGB(80, 200, 255),
	},
	spinKick = {
		name = "Spin Kick",
		cost = 75,
		description = "360 kick, hits from both sides",
		color = Color3.fromRGB(100, 255, 100),
	},
	fireball = {
		name = "Fireball",
		cost = 100,
		description = "Powerful fire projectile",
		color = Color3.fromRGB(255, 60, 30),
	},
	groundSlam = {
		name = "Ground Slam",
		cost = 150,
		description = "Jump slam with AoE shockwave",
		color = Color3.fromRGB(180, 100, 255),
	},
}

-- Ability attack data (same format as Config.Attacks)
Config.AbilityAttacks = {
	dashPunch = {
		damage = 12,
		range = 14,
		startup = 0.12,
		active = 0.1,
		recovery = 0.2,
		knockback = 12,
		hitstun = 0.25,
		isProjectile = false,
		dashSpeed = 55,
	},
	uppercut = {
		damage = 16,
		range = 7,
		startup = 0.1,
		active = 0.08,
		recovery = 0.25,
		knockback = 10,
		hitstun = 0.3,
		isProjectile = false,
		launchVY = 30,
	},
	spinKick = {
		damage = 12,
		range = 10,
		startup = 0.12,
		active = 0.1,
		recovery = 0.22,
		knockback = 8,
		hitstun = 0.25,
		isProjectile = false,
		hitsBothSides = true,
	},
	fireball = {
		damage = 25,
		range = 0,
		startup = 0.25,
		active = 0,
		recovery = 0.35,
		knockback = 16,
		hitstun = 0.4,
		isProjectile = true,
		projectileSpeed = 70,
		projectileLifetime = 2.5,
	},
	groundSlam = {
		damage = 22,
		range = 12,
		startup = 0.3,
		active = 0.15,
		recovery = 0.4,
		knockback = 14,
		hitstun = 0.35,
		isProjectile = false,
		isAoE = true,
	},
}

-- Ordered list for shop display
Config.ShopAbilityOrder = { "dashPunch", "uppercut", "spinKick", "fireball", "groundSlam" }

-- State names
Config.States = {
	IDLE = "idle",
	WALK = "walk",
	JUMP = "jump",
	PUNCH = "punch",
	KICK = "kick",
	SPECIAL = "special",
	BLOCK = "block",
	HITSTUN = "hitstun",
	KO = "ko",
	ABILITY1 = "ability1",
	ABILITY2 = "ability2",
}

-- Game phases
Config.Phases = {
	WAITING = "waiting",
	COUNTDOWN = "countdown",
	FIGHTING = "fighting",
	ROUND_END = "roundEnd",
	MATCH_END = "matchEnd",
}

-- Remote event names
Config.Remotes = {
	SEND_INPUT = "SendInput",
	GAME_STATE = "GameState",
	GAME_EVENT = "GameEvent",
	SELECT_DIFFICULTY = "SelectDifficulty",
	SHOP_PURCHASE = "ShopPurchase",
	EQUIP_ABILITY = "EquipAbility",
}

return Config
]]></ProtectedString>
        </Properties>
      </Item>
  </Item>
  <Item class="ServerScriptService" referent="RBXF4A234D8">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
      <Item class="Script" referent="RBX00000066">
        <Properties>
          <string name="Name">FightServer</string>
          <ProtectedString name="Source"><![CDATA[--[[
	FightServer - Main server script for Pixel Brawl
	LOCATION: ServerScriptService > FightServer (Script)

	Handles: matchmaking, AI bot, game loop, combat, rounds, state broadcasting,
	lobby, shop, tokens, abilities
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[PixelBrawl] Server script starting...")

local configModule = ReplicatedStorage:WaitForChild("FightConfig", 10)
if not configModule then
	warn("[PixelBrawl] ERROR: Could not find FightConfig in ReplicatedStorage! Make sure it exists as a ModuleScript.")
	return
end

print("[PixelBrawl] Found FightConfig, loading...")
local ok, Config = pcall(function()
	return require(configModule)
end)
if not ok then
	warn("[PixelBrawl] ERROR: Failed to load FightConfig: " .. tostring(Config))
	return
end
print("[PixelBrawl] FightConfig loaded successfully!")

-- ============================================================
-- CREATE REMOTE EVENTS
-- ============================================================
local remotesFolder = Instance.new("Folder")
remotesFolder.Name = "FightRemotes"
remotesFolder.Parent = ReplicatedStorage

local sendInputEvent = Instance.new("RemoteEvent")
sendInputEvent.Name = Config.Remotes.SEND_INPUT
sendInputEvent.Parent = remotesFolder

local gameStateEvent = Instance.new("RemoteEvent")
gameStateEvent.Name = Config.Remotes.GAME_STATE
gameStateEvent.Parent = remotesFolder

local gameEventEvent = Instance.new("RemoteEvent")
gameEventEvent.Name = Config.Remotes.GAME_EVENT
gameEventEvent.Parent = remotesFolder

local selectDifficultyEvent = Instance.new("RemoteEvent")
selectDifficultyEvent.Name = Config.Remotes.SELECT_DIFFICULTY
selectDifficultyEvent.Parent = remotesFolder

local shopPurchaseEvent = Instance.new("RemoteEvent")
shopPurchaseEvent.Name = Config.Remotes.SHOP_PURCHASE
shopPurchaseEvent.Parent = remotesFolder

local equipAbilityEvent = Instance.new("RemoteEvent")
equipAbilityEvent.Name = Config.Remotes.EQUIP_ABILITY
equipAbilityEvent.Parent = remotesFolder

-- ============================================================
-- CREATE ARENA
-- ============================================================
local function setupArena()
	local arena = workspace:FindFirstChild("Arena")
	if not arena then
		arena = Instance.new("Folder")
		arena.Name = "Arena"
		arena.Parent = workspace

		-- === FLOOR (fighting platform) ===
		local floor = Instance.new("Part")
		floor.Name = "Floor"
		floor.Size = Vector3.new(120, 2, 20)
		floor.Position = Vector3.new(0, -1, 0)
		floor.Anchored = true
		floor.Material = Enum.Material.Concrete
		floor.Color = Color3.fromRGB(50, 45, 45)
		floor.Parent = arena

		-- Floor stripe (center line)
		local centerLine = Instance.new("Part")
		centerLine.Name = "CenterLine"
		centerLine.Size = Vector3.new(1, 0.1, 20)
		centerLine.Position = Vector3.new(0, 0.05, 0)
		centerLine.Anchored = true
		centerLine.CanCollide = false
		centerLine.Material = Enum.Material.Neon
		centerLine.Color = Color3.fromRGB(255, 200, 50)
		centerLine.Parent = arena

		-- Floor edge glow left
		local edgeL = Instance.new("Part")
		edgeL.Name = "EdgeLeft"
		edgeL.Size = Vector3.new(2, 0.15, 20)
		edgeL.Position = Vector3.new(Config.ARENA_MIN_X, 0.07, 0)
		edgeL.Anchored = true
		edgeL.CanCollide = false
		edgeL.Material = Enum.Material.Neon
		edgeL.Color = Color3.fromRGB(220, 40, 40)
		edgeL.Parent = arena

		-- Floor edge glow right
		local edgeR = Instance.new("Part")
		edgeR.Name = "EdgeRight"
		edgeR.Size = Vector3.new(2, 0.15, 20)
		edgeR.Position = Vector3.new(Config.ARENA_MAX_X, 0.07, 0)
		edgeR.Anchored = true
		edgeR.CanCollide = false
		edgeR.Material = Enum.Material.Neon
		edgeR.Color = Color3.fromRGB(220, 40, 40)
		edgeR.Parent = arena

		-- === INVISIBLE WALLS ===
		local wallL = Instance.new("Part")
		wallL.Name = "WallLeft"
		wallL.Size = Vector3.new(2, 40, 20)
		wallL.Position = Vector3.new(Config.ARENA_MIN_X - 1, 19, 0)
		wallL.Anchored = true
		wallL.Transparency = 1
		wallL.CanCollide = true
		wallL.Parent = arena

		local wallR = Instance.new("Part")
		wallR.Name = "WallRight"
		wallR.Size = Vector3.new(2, 40, 20)
		wallR.Position = Vector3.new(Config.ARENA_MAX_X + 1, 19, 0)
		wallR.Anchored = true
		wallR.Transparency = 1
		wallR.CanCollide = true
		wallR.Parent = arena

		-- === BACKGROUND BUILDINGS ===
		local bgFolder = Instance.new("Folder")
		bgFolder.Name = "Background"
		bgFolder.Parent = arena

		local buildingData = {
			{ x = -55, w = 18, h = 45, color = Color3.fromRGB(35, 35, 50) },
			{ x = -35, w = 14, h = 60, color = Color3.fromRGB(30, 30, 45) },
			{ x = -18, w = 20, h = 38, color = Color3.fromRGB(40, 35, 50) },
			{ x = 0,   w = 16, h = 55, color = Color3.fromRGB(32, 32, 48) },
			{ x = 18,  w = 22, h = 42, color = Color3.fromRGB(38, 35, 52) },
			{ x = 38,  w = 14, h = 65, color = Color3.fromRGB(28, 28, 42) },
			{ x = 55,  w = 18, h = 35, color = Color3.fromRGB(36, 34, 48) },
		}

		for i, bd in ipairs(buildingData) do
			local building = Instance.new("Part")
			building.Name = "Building" .. i
			building.Size = Vector3.new(bd.w, bd.h, 6)
			building.Position = Vector3.new(bd.x, bd.h / 2, -25)
			building.Anchored = true
			building.CanCollide = false
			building.Material = Enum.Material.SmoothPlastic
			building.Color = bd.color
			building.Parent = bgFolder

			for row = 1, math.floor(bd.h / 6) do
				for col = 1, math.floor(bd.w / 5) do
					if math.random() > 0.35 then
						local window = Instance.new("Part")
						window.Name = "Window"
						window.Size = Vector3.new(1.5, 1.5, 0.2)
						window.Position = Vector3.new(
							bd.x - bd.w/2 + col * (bd.w / (math.floor(bd.w/5) + 1)),
							row * 5.5,
							-22
						)
						window.Anchored = true
						window.CanCollide = false
						window.Material = Enum.Material.Neon
						local windowColors = {
							Color3.fromRGB(255, 220, 100),
							Color3.fromRGB(100, 180, 255),
							Color3.fromRGB(255, 150, 80),
							Color3.fromRGB(200, 200, 255),
						}
						window.Color = windowColors[math.random(1, #windowColors)]
						window.Parent = bgFolder
					end
				end
			end
		end

		-- === NEON SIGNS ===
		local sign1 = Instance.new("Part")
		sign1.Name = "NeonSign1"
		sign1.Size = Vector3.new(12, 4, 0.5)
		sign1.Position = Vector3.new(-35, 30, -20)
		sign1.Anchored = true
		sign1.CanCollide = false
		sign1.Material = Enum.Material.Neon
		sign1.Color = Color3.fromRGB(255, 50, 100)
		sign1.Parent = bgFolder

		local signText1 = Instance.new("SurfaceGui")
		signText1.Face = Enum.NormalId.Front
		signText1.Parent = sign1
		local signLabel1 = Instance.new("TextLabel")
		signLabel1.Size = UDim2.new(1, 0, 1, 0)
		signLabel1.BackgroundTransparency = 1
		signLabel1.Text = "FIGHT!"
		signLabel1.TextColor3 = Color3.fromRGB(255, 255, 255)
		signLabel1.TextScaled = true
		signLabel1.Font = Enum.Font.GothamBlack
		signLabel1.Parent = signText1

		local sign2 = Instance.new("Part")
		sign2.Name = "NeonSign2"
		sign2.Size = Vector3.new(14, 3, 0.5)
		sign2.Position = Vector3.new(38, 35, -20)
		sign2.Anchored = true
		sign2.CanCollide = false
		sign2.Material = Enum.Material.Neon
		sign2.Color = Color3.fromRGB(50, 150, 255)
		sign2.Parent = bgFolder

		local signText2 = Instance.new("SurfaceGui")
		signText2.Face = Enum.NormalId.Front
		signText2.Parent = sign2
		local signLabel2 = Instance.new("TextLabel")
		signLabel2.Size = UDim2.new(1, 0, 1, 0)
		signLabel2.BackgroundTransparency = 1
		signLabel2.Text = "PIXEL BRAWL"
		signLabel2.TextColor3 = Color3.fromRGB(255, 255, 255)
		signLabel2.TextScaled = true
		signLabel2.Font = Enum.Font.GothamBlack
		signLabel2.Parent = signText2

		-- === GROUND DETAILS ===
		for i = -4, 4 do
			local strip = Instance.new("Part")
			strip.Name = "FloorStrip"
			strip.Size = Vector3.new(8, 0.1, 20)
			strip.Position = Vector3.new(i * 12, 0.06, 0)
			strip.Anchored = true
			strip.CanCollide = false
			strip.Material = Enum.Material.SmoothPlastic
			strip.Color = Color3.fromRGB(60, 55, 55)
			strip.Parent = bgFolder
		end

		-- === ARENA LIGHTS ===
		local light1 = Instance.new("Part")
		light1.Name = "ArenaLight1"
		light1.Size = Vector3.new(1, 1, 1)
		light1.Position = Vector3.new(-20, 35, 10)
		light1.Anchored = true
		light1.CanCollide = false
		light1.Transparency = 1
		light1.Parent = bgFolder

		local spot1 = Instance.new("SpotLight")
		spot1.Face = Enum.NormalId.Bottom
		spot1.Angle = 60
		spot1.Range = 50
		spot1.Brightness = 3
		spot1.Color = Color3.fromRGB(255, 230, 200)
		spot1.Parent = light1

		local light2 = Instance.new("Part")
		light2.Name = "ArenaLight2"
		light2.Size = Vector3.new(1, 1, 1)
		light2.Position = Vector3.new(20, 35, 10)
		light2.Anchored = true
		light2.CanCollide = false
		light2.Transparency = 1
		light2.Parent = bgFolder

		local spot2 = Instance.new("SpotLight")
		spot2.Face = Enum.NormalId.Bottom
		spot2.Angle = 60
		spot2.Range = 50
		spot2.Brightness = 3
		spot2.Color = Color3.fromRGB(255, 230, 200)
		spot2.Parent = light2

		-- === SET EVENING ATMOSPHERE ===
		local lighting = game:GetService("Lighting")
		lighting.ClockTime = 15
		lighting.Brightness = 3
		lighting.Ambient = Color3.fromRGB(170, 160, 180)
		lighting.OutdoorAmbient = Color3.fromRGB(150, 140, 160)
		lighting.FogEnd = 1000
		lighting.FogColor = Color3.fromRGB(180, 80, 80)

		local existingAtmo = lighting:FindFirstChildOfClass("Atmosphere")
		if not existingAtmo then
			local atmo = Instance.new("Atmosphere")
			atmo.Density = 0.2
			atmo.Offset = 0.5
			atmo.Color = Color3.fromRGB(200, 120, 120)
			atmo.Decay = Color3.fromRGB(180, 80, 80)
			atmo.Glare = 0.1
			atmo.Haze = 1.5
			atmo.Parent = lighting
		end

		local existingBloom = lighting:FindFirstChildOfClass("BloomEffect")
		if not existingBloom then
			local bloom = Instance.new("BloomEffect")
			bloom.Intensity = 0.6
			bloom.Size = 20
			bloom.Threshold = 0.9
			bloom.Parent = lighting
		end

		local existingCC = lighting:FindFirstChildOfClass("ColorCorrectionEffect")
		if not existingCC then
			local cc = Instance.new("ColorCorrectionEffect")
			cc.Brightness = 0.05
			cc.Contrast = 0.1
			cc.Saturation = 0.15
			cc.TintColor = Color3.fromRGB(255, 210, 210)
			cc.Parent = lighting
		end
	end
	return arena
end

local arena = setupArena()

-- ============================================================
-- CREATE LOBBY (bigger dojo at Z=300)
-- ============================================================
local function setupLobby()
	local lobby = Instance.new("Folder")
	lobby.Name = "Lobby"
	lobby.Parent = workspace

	local LZ = 300 -- lobby center Z

	-- Floor (dark wood dojo) — BIGGER: 120x100
	local floor = Instance.new("Part")
	floor.Name = "LobbyFloor"
	floor.Size = Vector3.new(120, 2, 100)
	floor.Position = Vector3.new(0, -1, LZ)
	floor.Anchored = true
	floor.Material = Enum.Material.WoodPlanks
	floor.Color = Color3.fromRGB(60, 40, 25)
	floor.Parent = lobby

	-- Tatami strips
	for i = -5, 5 do
		local strip = Instance.new("Part")
		strip.Size = Vector3.new(10, 0.05, 96)
		strip.Position = Vector3.new(i * 10, 0.03, LZ)
		strip.Anchored = true
		strip.CanCollide = false
		strip.Material = Enum.Material.Fabric
		strip.Color = (i % 2 == 0) and Color3.fromRGB(75, 55, 30) or Color3.fromRGB(55, 38, 20)
		strip.Parent = lobby
	end

	-- Walls — expanded
	local function makeWall(name, size, pos)
		local w = Instance.new("Part")
		w.Name = name
		w.Size = size
		w.Position = pos
		w.Anchored = true
		w.Material = Enum.Material.Wood
		w.Color = Color3.fromRGB(45, 35, 30)
		w.Parent = lobby
		return w
	end
	makeWall("BackWall", Vector3.new(120, 20, 2), Vector3.new(0, 9, LZ + 51))
	makeWall("LeftWall", Vector3.new(2, 20, 102), Vector3.new(-61, 9, LZ))
	makeWall("RightWall", Vector3.new(2, 20, 102), Vector3.new(61, 9, LZ))

	-- Invisible front boundary
	local frontWall = Instance.new("Part")
	frontWall.Size = Vector3.new(120, 20, 2)
	frontWall.Position = Vector3.new(0, 9, LZ - 51)
	frontWall.Anchored = true
	frontWall.Transparency = 1
	frontWall.Parent = lobby

	-- Roof with skylight
	local roof = Instance.new("Part")
	roof.Size = Vector3.new(124, 1, 104)
	roof.Position = Vector3.new(0, 19.5, LZ)
	roof.Anchored = true
	roof.Material = Enum.Material.Wood
	roof.Color = Color3.fromRGB(35, 25, 18)
	roof.Parent = lobby

	-- Skylight (neon center)
	local skylight = Instance.new("Part")
	skylight.Size = Vector3.new(30, 0.5, 30)
	skylight.Position = Vector3.new(0, 19.8, LZ)
	skylight.Anchored = true
	skylight.CanCollide = false
	skylight.Material = Enum.Material.Neon
	skylight.Color = Color3.fromRGB(200, 180, 140)
	skylight.Parent = lobby

	-- PIXEL BRAWL sign on back wall
	local signPart = Instance.new("Part")
	signPart.Size = Vector3.new(30, 6, 0.5)
	signPart.Position = Vector3.new(0, 14, LZ + 49.5)
	signPart.Anchored = true
	signPart.CanCollide = false
	signPart.Material = Enum.Material.SmoothPlastic
	signPart.Color = Color3.fromRGB(15, 15, 25)
	signPart.Parent = lobby
	local function makeMainSign(face)
		local sGui = Instance.new("SurfaceGui")
		sGui.Face = face
		sGui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
		sGui.PixelsPerStud = 50
		sGui.Parent = signPart
		local sBg = Instance.new("Frame")
		sBg.Size = UDim2.new(1, 0, 1, 0)
		sBg.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
		sBg.BorderSizePixel = 0
		sBg.Parent = sGui
		local sText = Instance.new("TextLabel")
		sText.Size = UDim2.new(1, 0, 1, 0)
		sText.BackgroundTransparency = 1
		sText.Text = "PIXEL BRAWL"
		sText.TextColor3 = Color3.fromRGB(255, 60, 30)
		sText.TextScaled = true
		sText.Font = Enum.Font.GothamBlack
		sText.TextStrokeTransparency = 0
		sText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		sText.Parent = sBg
	end
	makeMainSign(Enum.NormalId.Front)
	makeMainSign(Enum.NormalId.Back)
	local signGlow = Instance.new("PointLight")
	signGlow.Color = Color3.fromRGB(255, 60, 30)
	signGlow.Brightness = 2
	signGlow.Range = 20
	signGlow.Parent = signPart

	-- === PORTAL BUILDER ===
	local function makePortal(name, posX, posZ, color, labelText)
		local portalFolder = Instance.new("Folder")
		portalFolder.Name = name
		portalFolder.Parent = lobby

		local pad = Instance.new("Part")
		pad.Size = Vector3.new(12, 0.3, 12)
		pad.Position = Vector3.new(posX, 0.15, posZ)
		pad.Anchored = true
		pad.CanCollide = false
		pad.Material = Enum.Material.Neon
		pad.Color = color
		pad.Parent = portalFolder

		local lPillar = Instance.new("Part")
		lPillar.Size = Vector3.new(1, 10, 1)
		lPillar.Position = Vector3.new(posX - 6, 5, posZ)
		lPillar.Anchored = true
		lPillar.Material = Enum.Material.SmoothPlastic
		lPillar.Color = color
		lPillar.Parent = portalFolder

		local rPillar = Instance.new("Part")
		rPillar.Size = Vector3.new(1, 10, 1)
		rPillar.Position = Vector3.new(posX + 6, 5, posZ)
		rPillar.Anchored = true
		rPillar.Material = Enum.Material.SmoothPlastic
		rPillar.Color = color
		rPillar.Parent = portalFolder

		local topBeam = Instance.new("Part")
		topBeam.Size = Vector3.new(14, 1, 1.5)
		topBeam.Position = Vector3.new(posX, 10.5, posZ)
		topBeam.Anchored = true
		topBeam.Material = Enum.Material.SmoothPlastic
		topBeam.Color = color
		topBeam.Parent = portalFolder

		local sPart = Instance.new("Part")
		sPart.Size = Vector3.new(12, 4, 0.5)
		sPart.Position = Vector3.new(posX, 13.5, posZ)
		sPart.Anchored = true
		sPart.CanCollide = false
		sPart.Material = Enum.Material.SmoothPlastic
		sPart.Color = Color3.fromRGB(20, 20, 30)
		sPart.Parent = portalFolder

		local function makeSignGui(face)
			local sGui = Instance.new("SurfaceGui")
			sGui.Face = face
			sGui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
			sGui.PixelsPerStud = 50
			sGui.Parent = sPart

			local bg = Instance.new("Frame")
			bg.Size = UDim2.new(1, 0, 1, 0)
			bg.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
			bg.BorderSizePixel = 0
			bg.Parent = sGui

			local topLine = Instance.new("Frame")
			topLine.Size = UDim2.new(1, 0, 0, 6)
			topLine.Position = UDim2.new(0, 0, 0, 0)
			topLine.BackgroundColor3 = color
			topLine.BorderSizePixel = 0
			topLine.Parent = bg

			local botLine = Instance.new("Frame")
			botLine.Size = UDim2.new(1, 0, 0, 6)
			botLine.Position = UDim2.new(0, 0, 1, -6)
			botLine.BackgroundColor3 = color
			botLine.BorderSizePixel = 0
			botLine.Parent = bg

			local sText = Instance.new("TextLabel")
			sText.Size = UDim2.new(1, 0, 1, 0)
			sText.BackgroundTransparency = 1
			sText.Text = labelText
			sText.TextColor3 = Color3.fromRGB(255, 255, 255)
			sText.TextScaled = true
			sText.Font = Enum.Font.GothamBlack
			sText.TextStrokeTransparency = 0
			sText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
			sText.Parent = bg
		end

		makeSignGui(Enum.NormalId.Front)
		makeSignGui(Enum.NormalId.Back)

		local padLight = Instance.new("PointLight")
		padLight.Color = color
		padLight.Brightness = 3
		padLight.Range = 16
		padLight.Parent = pad

		return portalFolder
	end

	-- Portals wider apart
	makePortal("VSBotPortal", -30, LZ - 15, Color3.fromRGB(220, 40, 40), "VS BOT")
	makePortal("VSFriendPortal", 30, LZ - 15, Color3.fromRGB(130, 50, 200), "VS FRIEND")
	-- SHOP portal (gold, center-front)
	makePortal("ShopPortal", 0, LZ - 35, Color3.fromRGB(255, 200, 50), "SHOP")

	-- Lanterns (6 around the bigger room)
	local lanternPositions = {
		Vector3.new(-50, 6, LZ + 40),
		Vector3.new(50, 6, LZ + 40),
		Vector3.new(-50, 6, LZ),
		Vector3.new(50, 6, LZ),
		Vector3.new(-50, 6, LZ - 40),
		Vector3.new(50, 6, LZ - 40),
	}
	for _, lpos in ipairs(lanternPositions) do
		local lantern = Instance.new("Part")
		lantern.Size = Vector3.new(1.5, 2, 1.5)
		lantern.Position = lpos
		lantern.Anchored = true
		lantern.CanCollide = false
		lantern.Material = Enum.Material.Neon
		lantern.Color = Color3.fromRGB(255, 160, 50)
		lantern.Shape = Enum.PartType.Cylinder
		lantern.Parent = lobby
		local ll = Instance.new("PointLight")
		ll.Color = Color3.fromRGB(255, 160, 50)
		ll.Brightness = 2
		ll.Range = 25
		ll.Parent = lantern
	end

	-- Weapon rack on back wall
	local rack = Instance.new("Part")
	rack.Size = Vector3.new(15, 0.5, 0.5)
	rack.Position = Vector3.new(-30, 8, LZ + 49.5)
	rack.Anchored = true
	rack.Material = Enum.Material.Wood
	rack.Color = Color3.fromRGB(80, 50, 30)
	rack.Parent = lobby
	for i = -2, 2 do
		local staff = Instance.new("Part")
		staff.Size = Vector3.new(0.3, 6, 0.3)
		staff.Position = Vector3.new(-30 + i * 3, 8, LZ + 49.3)
		staff.Anchored = true
		staff.CanCollide = false
		staff.Material = Enum.Material.Wood
		staff.Color = Color3.fromRGB(120, 80, 40)
		staff.Rotation = Vector3.new(0, 0, 15 + i * 5)
		staff.Parent = lobby
	end

	return lobby
end

local lobby = setupLobby()

-- ============================================================
-- PLAYER STATE TRACKING
-- ============================================================
local playerState = {}      -- [UserId] = "lobby" | "inMatch" | "queued"
local zoneCooldown = {}      -- [UserId] = tick() of last zone trigger
local playerTokens = {}      -- [UserId] = number (battle tokens)
local playerInventory = {}   -- [UserId] = { ["dashPunch"] = true, ... }
local playerEquipped = {}    -- [UserId] = { [1] = "dashPunch" or nil, [2] = nil }

local function teleportToLobby(player)
	playerState[player.UserId] = Config.PlayerStates.LOBBY
	local char = player.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then
		player:LoadCharacter()
		return
	end
	char.HumanoidRootPart.CFrame = CFrame.new(Config.LOBBY_SPAWN)
	char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum then
		hum.MaxHealth = 100
		hum.Health = 100
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
end

-- Send token/inventory/equip state to a player
local function sendPlayerData(player)
	local uid = player.UserId
	gameEventEvent:FireClient(player, "tokenUpdate", {
		tokens = playerTokens[uid] or 0,
	})

	-- Convert inventory dict { dashPunch = true } to array { "dashPunch" }
	local invArray = {}
	if playerInventory[uid] then
		for key, owned in pairs(playerInventory[uid]) do
			if owned then
				table.insert(invArray, key)
			end
		end
	end

	local eq = playerEquipped[uid] or {}
	gameEventEvent:FireClient(player, "inventoryUpdate", {
		inventory = invArray,
		equipped1 = eq[1],
		equipped2 = eq[2],
	})
end

-- ============================================================
-- AI BOT SYSTEM
-- ============================================================
local AI_BOT = { Name = "CPU Fighter", UserId = -1, Parent = true, IsBot = true }

local playerDifficulty = {}

local AI_SETTINGS = {
	easy = { attackChance = 0.03, blockChance = 0.15, specialChance = 0.01, reactionDist = 10 },
	medium = { attackChance = 0.08, blockChance = 0.35, specialChance = 0.03, reactionDist = 15 },
	hard = { attackChance = 0.14, blockChance = 0.55, specialChance = 0.06, reactionDist = 20 },
}

local function createBotModel(spawnX)
	local model = Instance.new("Model")
	model.Name = "CPU Fighter"

	local function makePart(name, size, pos, color, material, shape)
		local p = Instance.new("Part")
		p.Name = name
		p.Size = size
		p.Position = pos
		p.Anchored = true
		p.CanCollide = false
		p.Material = material or Enum.Material.SmoothPlastic
		p.Color = color
		if shape then p.Shape = shape end
		p.Parent = model
		return p
	end

	local torso = makePart("HumanoidRootPart",
		Vector3.new(2.2, 2.4, 1.2),
		Vector3.new(spawnX, 4.2, 0),
		Color3.fromRGB(25, 25, 35), Enum.Material.Fabric)
	model.PrimaryPart = torso

	local chest = makePart("Chest",
		Vector3.new(0.8, 0.6, 0.1),
		Vector3.new(spawnX, 5.0, -0.56),
		Color3.fromRGB(180, 130, 90), Enum.Material.SmoothPlastic)

	local belt = makePart("Belt",
		Vector3.new(2.3, 0.3, 1.3),
		Vector3.new(spawnX, 2.9, 0),
		Color3.fromRGB(180, 20, 20), Enum.Material.Fabric)

	local head = makePart("Head",
		Vector3.new(1.6, 1.6, 1.6),
		Vector3.new(spawnX, 6.3, 0),
		Color3.fromRGB(180, 130, 90), Enum.Material.SmoothPlastic, Enum.PartType.Ball)

	local headband = makePart("Headband",
		Vector3.new(1.8, 0.25, 1.8),
		Vector3.new(spawnX, 6.5, 0),
		Color3.fromRGB(200, 20, 20), Enum.Material.Fabric)

	local hbTail = makePart("HeadbandTail",
		Vector3.new(0.2, 0.15, 1.2),
		Vector3.new(spawnX - 0.8, 6.4, -0.6),
		Color3.fromRGB(200, 20, 20), Enum.Material.Fabric)

	local lEye = makePart("LeftEye",
		Vector3.new(0.2, 0.15, 0.1),
		Vector3.new(spawnX - 0.3, 6.4, -0.75),
		Color3.fromRGB(255, 255, 255), Enum.Material.Neon)
	local rEye = makePart("RightEye",
		Vector3.new(0.2, 0.15, 0.1),
		Vector3.new(spawnX + 0.3, 6.4, -0.75),
		Color3.fromRGB(255, 255, 255), Enum.Material.Neon)

	local lPupil = makePart("LeftPupil",
		Vector3.new(0.1, 0.1, 0.1),
		Vector3.new(spawnX - 0.3, 6.4, -0.81),
		Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic)
	local rPupil = makePart("RightPupil",
		Vector3.new(0.1, 0.1, 0.1),
		Vector3.new(spawnX + 0.3, 6.4, -0.81),
		Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic)

	local lArm = makePart("LeftArm",
		Vector3.new(0.9, 2.2, 0.9),
		Vector3.new(spawnX - 1.55, 4.2, 0),
		Color3.fromRGB(25, 25, 35), Enum.Material.Fabric)
	local rArm = makePart("RightArm",
		Vector3.new(0.9, 2.2, 0.9),
		Vector3.new(spawnX + 1.55, 4.2, 0),
		Color3.fromRGB(25, 25, 35), Enum.Material.Fabric)

	local lFist = makePart("LeftFist",
		Vector3.new(0.6, 0.6, 0.6),
		Vector3.new(spawnX - 1.55, 2.9, 0),
		Color3.fromRGB(255, 80, 30), Enum.Material.Neon)
	local rFist = makePart("RightFist",
		Vector3.new(0.6, 0.6, 0.6),
		Vector3.new(spawnX + 1.55, 2.9, 0),
		Color3.fromRGB(255, 80, 30), Enum.Material.Neon)

	local lLeg = makePart("LeftLeg",
		Vector3.new(0.9, 2.2, 0.9),
		Vector3.new(spawnX - 0.55, 1.1, 0),
		Color3.fromRGB(30, 30, 50), Enum.Material.Fabric)
	local rLeg = makePart("RightLeg",
		Vector3.new(0.9, 2.2, 0.9),
		Vector3.new(spawnX + 0.55, 1.1, 0),
		Color3.fromRGB(30, 30, 50), Enum.Material.Fabric)

	local lShoe = makePart("LeftShoe",
		Vector3.new(1.0, 0.5, 1.3),
		Vector3.new(spawnX - 0.55, 0.25, 0),
		Color3.fromRGB(15, 15, 15), Enum.Material.SmoothPlastic)
	local rShoe = makePart("RightShoe",
		Vector3.new(1.0, 0.5, 1.3),
		Vector3.new(spawnX + 0.55, 0.25, 0),
		Color3.fromRGB(15, 15, 15), Enum.Material.SmoothPlastic)

	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(0, 120, 0, 40)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Adornee = head
	billboard.Parent = head

	local nameTag = Instance.new("TextLabel")
	nameTag.Size = UDim2.new(1, 0, 1, 0)
	nameTag.BackgroundTransparency = 1
	nameTag.Text = "CPU FIGHTER"
	nameTag.TextColor3 = Color3.fromRGB(255, 80, 30)
	nameTag.TextStrokeTransparency = 0
	nameTag.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	nameTag.TextSize = 16
	nameTag.Font = Enum.Font.GothamBlack
	nameTag.Parent = billboard

	local lGlow = Instance.new("PointLight")
	lGlow.Color = Color3.fromRGB(255, 80, 30)
	lGlow.Brightness = 2
	lGlow.Range = 4
	lGlow.Parent = lFist
	local rGlow = Instance.new("PointLight")
	rGlow.Color = Color3.fromRGB(255, 80, 30)
	rGlow.Brightness = 2
	rGlow.Range = 4
	rGlow.Parent = rFist

	model.Parent = workspace
	return model
end

local function updateBotModel(model, fighter)
	if not model or not model.Parent then return end
	local x = fighter.x
	local yOff = fighter.y - Config.GROUND_Y
	local dir = fighter.facingRight and 1 or -1

	local layout = {
		{ "HumanoidRootPart", 0, 4.2 },
		{ "Chest", 0, 5.0 },
		{ "Belt", 0, 2.9 },
		{ "Head", 0, 6.3 },
		{ "Headband", 0, 6.5 },
		{ "HeadbandTail", -0.8, 6.4 },
		{ "LeftEye", -0.3, 6.4 },
		{ "RightEye", 0.3, 6.4 },
		{ "LeftPupil", -0.3, 6.4 },
		{ "RightPupil", 0.3, 6.4 },
		{ "LeftArm", -1.55, 4.2 },
		{ "RightArm", 1.55, 4.2 },
		{ "LeftFist", -1.55, 2.9 },
		{ "RightFist", 1.55, 2.9 },
		{ "LeftLeg", -0.55, 1.1 },
		{ "RightLeg", 0.55, 1.1 },
		{ "LeftShoe", -0.55, 0.25 },
		{ "RightShoe", 0.55, 0.25 },
	}

	local armPunch = 0
	local fistPunch = 0
	local legKick = 0
	local shoeKick = 0
	local crouch = 0
	local breathe = math.sin(tick() * 3) * 0.05

	local st = fighter.state
	if st == "punch" or st == "ability1" or st == "ability2" then
		armPunch = dir * 2.0
		fistPunch = dir * 2.5
	elseif st == "kick" then
		legKick = dir * 2.5
		shoeKick = dir * 3.0
	elseif st == "block" then
		crouch = 0.6
		armPunch = -dir * 0.5
	elseif st == "special" then
		armPunch = dir * 1.5
		fistPunch = dir * 2.0
	end

	if st == "hitstun" then
		local flash = math.sin(tick() * 30) > 0
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") and child.Name ~= "LeftEye" and child.Name ~= "RightEye"
				and child.Name ~= "LeftPupil" and child.Name ~= "RightPupil" then
				if flash then
					child.Color = Color3.fromRGB(255, 200, 200)
				else
					child.Color = Color3.fromRGB(255, 60, 60)
				end
			end
		end
	elseif st == "ko" then
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") then
				child.Color = Color3.fromRGB(80, 80, 90)
				child.Position = Vector3.new(x + (math.random() - 0.5) * 2, 0.3, 0)
			end
		end
		for _, child in ipairs(model:GetDescendants()) do
			if child:IsA("PointLight") then child.Enabled = false end
		end
		return
	else
		local colorMap = {
			HumanoidRootPart = Color3.fromRGB(25, 25, 35),
			Chest = Color3.fromRGB(180, 130, 90),
			Belt = Color3.fromRGB(180, 20, 20),
			Head = Color3.fromRGB(180, 130, 90),
			Headband = Color3.fromRGB(200, 20, 20),
			HeadbandTail = Color3.fromRGB(200, 20, 20),
			LeftEye = Color3.fromRGB(255, 255, 255),
			RightEye = Color3.fromRGB(255, 255, 255),
			LeftPupil = Color3.fromRGB(20, 20, 20),
			RightPupil = Color3.fromRGB(20, 20, 20),
			LeftArm = Color3.fromRGB(25, 25, 35),
			RightArm = Color3.fromRGB(25, 25, 35),
			LeftFist = Color3.fromRGB(255, 80, 30),
			RightFist = Color3.fromRGB(255, 80, 30),
			LeftLeg = Color3.fromRGB(30, 30, 50),
			RightLeg = Color3.fromRGB(30, 30, 50),
			LeftShoe = Color3.fromRGB(15, 15, 15),
			RightShoe = Color3.fromRGB(15, 15, 15),
		}
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") and colorMap[child.Name] then
				child.Color = colorMap[child.Name]
			end
		end
		for _, child in ipairs(model:GetDescendants()) do
			if child:IsA("PointLight") then child.Enabled = true end
		end
		if st == "punch" or st == "special" or st == "ability1" or st == "ability2" then
			for _, child in ipairs(model:GetDescendants()) do
				if child:IsA("PointLight") then
					child.Brightness = 5
					child.Range = 8
				end
			end
		else
			for _, child in ipairs(model:GetDescendants()) do
				if child:IsA("PointLight") then
					child.Brightness = 2
					child.Range = 4
				end
			end
		end
	end

	for _, info in ipairs(layout) do
		local part = model:FindFirstChild(info[1])
		if part then
			local px = x + info[2]
			local py = yOff + info[3] - crouch + breathe

			if info[1] == "RightArm" then px = px + armPunch end
			if info[1] == "RightFist" then px = px + fistPunch end
			if st == "block" and (info[1] == "LeftArm" or info[1] == "LeftFist") then
				px = px - armPunch
			end
			if info[1] == "RightLeg" then px = px + legKick end
			if info[1] == "RightShoe" then px = px + shoeKick end

			if info[1] == "HeadbandTail" then
				px = x + (dir * -0.8)
			end

			part.Position = Vector3.new(px, py, 0)
		end
	end
end

local function destroyBotModel(model)
	if model and model.Parent then
		model:Destroy()
	end
end

local function createAIInput(self, opponent, difficulty)
	local input = {
		left = false, right = false, jump = false,
		block = false, punch = false, kick = false, special = false,
		ability1 = false, ability2 = false,
	}
	if not opponent then return input end

	local settings = AI_SETTINGS[difficulty or "medium"]
	local dist = math.abs(self.x - opponent.x)
	local dir = self.x < opponent.x and 1 or -1
	local goRight = dir > 0

	if (opponent.state == "punch" or opponent.state == "kick" or opponent.state == "special"
		or opponent.state == "ability1" or opponent.state == "ability2") and dist < settings.reactionDist then
		if math.random() < settings.blockChance then
			input.block = true
			return input
		end
	end

	if dist > 25 then
		if math.random() < settings.specialChance then
			input.special = true
		else
			if goRight then input.right = true else input.left = true end
		end
	elseif dist > 10 then
		local roll = math.random()
		if roll < settings.attackChance * 0.5 then
			input.kick = true
		elseif roll < settings.attackChance * 0.7 then
			input.punch = true
		elseif roll < settings.attackChance then
			input.jump = true
			if goRight then input.right = true else input.left = true end
		else
			if goRight then input.right = true else input.left = true end
		end
	else
		local roll = math.random()
		if roll < settings.attackChance then
			input.punch = true
		elseif roll < settings.attackChance * 1.8 then
			input.kick = true
		elseif roll < settings.attackChance * 2 then
			input.special = true
		elseif roll < settings.attackChance * 2.2 then
			input.block = true
		elseif roll < settings.attackChance * 2.5 then
			if goRight then input.left = true else input.right = true end
		elseif roll < settings.attackChance * 2.7 then
			input.jump = true
		end
	end

	return input
end

-- ============================================================
-- MATCHMAKING & MATCH STATE
-- ============================================================
local activeMatches = {}
local pvpQueue = {}

local function createFighterState(player, spawnX, facingRight)
	-- Copy equipped abilities from player data
	local equipped = { nil, nil }
	if player ~= AI_BOT and playerEquipped[player.UserId] then
		equipped = { playerEquipped[player.UserId][1], playerEquipped[player.UserId][2] }
	end

	return {
		player = player,
		x = spawnX,
		y = Config.GROUND_Y,
		vx = 0,
		vy = 0,
		health = Config.MAX_HEALTH,
		state = Config.States.IDLE,
		stateTimer = 0,
		facingRight = facingRight,
		attackHit = false,
		roundWins = 0,
		input = {
			left = false, right = false, jump = false,
			block = false, punch = false, kick = false, special = false,
			ability1 = false, ability2 = false,
		},
		prevInput = {},
		onGround = true,
		isBot = (player == AI_BOT),
		equippedAbilities = equipped,
	}
end

local function getMatchForPlayer(player)
	for matchId, match in pairs(activeMatches) do
		for i, f in ipairs(match.fighters) do
			if f.player == player then
				return match, i
			end
		end
	end
	return nil, nil
end

local function isInMatch(player)
	return getMatchForPlayer(player) ~= nil
end

local function fireToFighters(match, eventName, data)
	for _, f in ipairs(match.fighters) do
		if not f.isBot and f.player.Parent then
			gameEventEvent:FireClient(f.player, eventName, data)
		end
	end
end

-- Forward declaration
local startMatchWithAI

-- ============================================================
-- GET ATTACK DATA (resolves ability or base attack)
-- ============================================================
local function getAttackData(fighter, stateName)
	if stateName == Config.States.ABILITY1 then
		local abilityKey = fighter.equippedAbilities[1]
		if abilityKey and Config.AbilityAttacks[abilityKey] then
			return Config.AbilityAttacks[abilityKey], abilityKey
		end
		return Config.Attacks.punch, "punch" -- fallback
	elseif stateName == Config.States.ABILITY2 then
		local abilityKey = fighter.equippedAbilities[2]
		if abilityKey and Config.AbilityAttacks[abilityKey] then
			return Config.AbilityAttacks[abilityKey], abilityKey
		end
		return Config.Attacks.punch, "punch" -- fallback
	elseif Config.Attacks[stateName] then
		return Config.Attacks[stateName], stateName
	end
	return nil, nil
end

-- ============================================================
-- END MATCH (with token rewards)
-- ============================================================
local function endMatch(match)
	local winner = match.fighters[1].roundWins >= Config.ROUNDS_TO_WIN and 1 or 2
	local winnerName = match.fighters[winner].player.Name

	fireToFighters(match, "matchEnd", {
		winner = winner,
		winnerName = winnerName,
	})

	match.phase = Config.Phases.MATCH_END
	match.phaseTimer = Config.MATCH_END_DELAY

	-- Award tokens for bot wins ONLY
	if match.botModel then
		-- Find the human player
		for _, f in ipairs(match.fighters) do
			if not f.isBot and f.player.Parent then
				-- Did the human win?
				if f.roundWins >= Config.ROUNDS_TO_WIN then
					local diff = playerDifficulty[f.player.UserId] or "medium"
					local reward = Config.TOKEN_REWARDS[diff] or 10
					playerTokens[f.player.UserId] = (playerTokens[f.player.UserId] or 0) + reward
					print("[PixelBrawl] " .. f.player.Name .. " won! +" .. reward .. " tokens (total: " .. playerTokens[f.player.UserId] .. ")")
					gameEventEvent:FireClient(f.player, "tokenReward", { amount = reward, total = playerTokens[f.player.UserId] })
				end
			end
		end
	end

	-- Clean up bot model
	if match.botModel then
		destroyBotModel(match.botModel)
		match.botModel = nil
	end

	task.delay(Config.MATCH_END_DELAY + 1, function()
		for _, f in ipairs(match.fighters) do
			if not f.isBot and f.player.Parent then
				teleportToLobby(f.player)
				gameEventEvent:FireClient(f.player, "enterLobby", {})
				sendPlayerData(f.player)
			end
		end
		activeMatches[match.id] = nil
	end)
end

local function createMatch(player1, player2)
	local matchId = tostring(tick()) .. "_" .. player1.UserId
	local match = {
		id = matchId,
		phase = Config.Phases.COUNTDOWN,
		fighters = {
			createFighterState(player1, -30, true),
			createFighterState(player2, 30, false),
		},
		timer = Config.COUNTDOWN_TIME,
		roundTimer = Config.ROUND_TIME,
		currentRound = 1,
		projectiles = {},
		phaseTimer = Config.COUNTDOWN_TIME,
	}
	activeMatches[matchId] = match

	if player2 == AI_BOT then
		match.botModel = createBotModel(30)
	elseif player1 == AI_BOT then
		match.botModel = createBotModel(-30)
	end

	-- Debug: print equipped abilities at match start
	for i, f in ipairs(match.fighters) do
		print("[PixelBrawl] Fighter " .. i .. " (" .. f.player.Name .. ") equippedAbilities: [1]=" .. tostring(f.equippedAbilities[1]) .. " [2]=" .. tostring(f.equippedAbilities[2]))
	end

	if not (player1 == AI_BOT) then
		gameEventEvent:FireClient(player1, "matchStart", {
			matchId = matchId, playerIndex = 1, opponentName = player2.Name,
		})
	end
	if not (player2 == AI_BOT) then
		gameEventEvent:FireClient(player2, "matchStart", {
			matchId = matchId, playerIndex = 2, opponentName = player1.Name,
		})
	end

	if not (player1 == AI_BOT) then
		local char1 = player1.Character
		if char1 and char1:FindFirstChild("HumanoidRootPart") then
			char1.HumanoidRootPart.CFrame = CFrame.new(-30, Config.GROUND_Y + 3, 0)
		end
	end
	if not (player2 == AI_BOT) then
		local char2 = player2.Character
		if char2 and char2:FindFirstChild("HumanoidRootPart") then
			char2.HumanoidRootPart.CFrame = CFrame.new(30, Config.GROUND_Y + 3, 0)
		end
	end

	for _, f in ipairs(match.fighters) do
		if not f.isBot and f.player.Character then
			local hum = f.player.Character:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.MaxHealth = math.huge
				hum.Health = math.huge
			end
		end
	end

	return match
end

-- ============================================================
-- COMBAT LOGIC
-- ============================================================
local function applyPhysics(fighter, dt)
	fighter.x = fighter.x + fighter.vx * dt
	fighter.y = fighter.y + fighter.vy * dt
	if not fighter.onGround then
		fighter.vy = fighter.vy - 120 * dt
	end
	if fighter.y <= Config.GROUND_Y and fighter.vy <= 0 then
		fighter.y = Config.GROUND_Y
		fighter.vy = 0
		fighter.onGround = true
	end
	if fighter.state == Config.States.HITSTUN then
		fighter.vx = fighter.vx * (1 - 5 * dt)
	end
	fighter.x = math.clamp(fighter.x, Config.ARENA_MIN_X + 2, Config.ARENA_MAX_X - 2)
end

local function checkHit(attacker, defender, attackData)
	if defender.state == Config.States.KO then return end
	if attacker.attackHit then return end

	local dir = attacker.facingRight and 1 or -1

	-- AoE: hits in radius ignoring direction
	if attackData.isAoE then
		local dist = math.abs(attacker.x - defender.x)
		local yDist = math.abs(attacker.y - defender.y)
		if dist < attackData.range and yDist < 10 then
			attacker.attackHit = true
			if defender.state == Config.States.BLOCK then
				defender.health = defender.health - attackData.damage * Config.BLOCK_REDUCTION
				local pushDir = defender.x > attacker.x and 1 or -1
				defender.vx = pushDir * attackData.knockback * Config.BLOCK_KNOCKBACK_MULT
				return "blocked"
			else
				defender.health = defender.health - attackData.damage
				defender.state = Config.States.HITSTUN
				defender.stateTimer = attackData.hitstun
				local pushDir = defender.x > attacker.x and 1 or -1
				defender.vx = pushDir * attackData.knockback
				defender.vy = 5
				return "hit"
			end
		end
		return nil
	end

	-- hitsBothSides: check both directions
	if attackData.hitsBothSides then
		local dist = math.abs(attacker.x - defender.x)
		local yDist = math.abs(attacker.y - defender.y)
		if dist < attackData.range and yDist < 8 then
			attacker.attackHit = true
			if defender.state == Config.States.BLOCK then
				defender.health = defender.health - attackData.damage * Config.BLOCK_REDUCTION
				local pushDir = defender.x > attacker.x and 1 or -1
				defender.vx = pushDir * attackData.knockback * Config.BLOCK_KNOCKBACK_MULT
				return "blocked"
			else
				defender.health = defender.health - attackData.damage
				defender.state = Config.States.HITSTUN
				defender.stateTimer = attackData.hitstun
				local pushDir = defender.x > attacker.x and 1 or -1
				defender.vx = pushDir * attackData.knockback
				defender.vy = 3
				return "hit"
			end
		end
		return nil
	end

	-- Normal directional hit
	local hitX = attacker.x + dir * attackData.range
	local dist = math.abs(hitX - defender.x)
	local yDist = math.abs(attacker.y - defender.y)

	if dist < 8 and yDist < 8 then
		attacker.attackHit = true
		if defender.state == Config.States.BLOCK then
			defender.health = defender.health - attackData.damage * Config.BLOCK_REDUCTION
			defender.vx = dir * attackData.knockback * Config.BLOCK_KNOCKBACK_MULT
			return "blocked"
		else
			defender.health = defender.health - attackData.damage
			defender.state = Config.States.HITSTUN
			defender.stateTimer = attackData.hitstun
			defender.vx = dir * attackData.knockback
			defender.vy = 3
			-- Launch upward for uppercut
			if attackData.launchVY then
				defender.vy = attackData.launchVY
				defender.onGround = false
			end
			return "hit"
		end
	end
	return nil
end

local function updateFighter(fighter, opponent, dt, match)
	if fighter.state == Config.States.KO then return end
	fighter.stateTimer = math.max(0, fighter.stateTimer - dt)

	if fighter.isBot then
		local diff = "medium"
		for _, f in ipairs(match and match.fighters or {}) do
			if not f.isBot and f.player then
				diff = playerDifficulty[f.player.UserId] or "medium"
			end
		end
		fighter.input = createAIInput(fighter, opponent, diff)
	end

	local input = fighter.input

	if fighter.state == Config.States.HITSTUN then
		if fighter.stateTimer <= 0 then fighter.state = Config.States.IDLE end
		applyPhysics(fighter, dt)
		return
	end

	-- Check if in an attack state (base or ability)
	local attackName = nil
	local st = fighter.state
	if st == Config.States.PUNCH then attackName = "punch"
	elseif st == Config.States.KICK then attackName = "kick"
	elseif st == Config.States.SPECIAL then attackName = "special"
	elseif st == Config.States.ABILITY1 then attackName = "ability1"
	elseif st == Config.States.ABILITY2 then attackName = "ability2"
	end

	if attackName then
		local atk, atkKey = getAttackData(fighter, st)
		if not atk then
			fighter.state = Config.States.IDLE
			applyPhysics(fighter, dt)
			return
		end

		local totalTime = atk.startup + atk.active + atk.recovery
		local elapsed = totalTime - fighter.stateTimer

		-- Dash punch: set velocity during startup + active (smooth lunge)
		if atk.dashSpeed then
			local dir = fighter.facingRight and 1 or -1
			if elapsed < atk.startup + atk.active then
				-- Ramp down speed: full during startup, half during active
				local speedMult = elapsed < atk.startup and 1.0 or 0.4
				fighter.vx = dir * atk.dashSpeed * speedMult
			else
				-- Recovery: decelerate
				fighter.vx = fighter.vx * (1 - 8 * dt)
			end
		end

		if not atk.isProjectile then
			if elapsed >= atk.startup and elapsed < atk.startup + atk.active and not fighter.attackHit then
				local result = checkHit(fighter, opponent, atk)
				if result then
					fireToFighters(match, result, { x = opponent.x, y = opponent.y, attackType = atkKey or attackName })
				end
			end
		end

		if atk.isProjectile and elapsed >= atk.startup and elapsed < atk.startup + dt * 2 then
			local dir = fighter.facingRight and 1 or -1
			table.insert(match.projectiles, {
				x = fighter.x + dir * 4, y = fighter.y + 3,
				vx = dir * atk.projectileSpeed, owner = fighter,
				life = atk.projectileLifetime, damage = atk.damage,
				knockback = atk.knockback, hitstun = atk.hitstun,
			})
			fireToFighters(match, "projectile", { x = fighter.x + dir * 4, y = fighter.y + 3, dir = dir })
		end

		if fighter.stateTimer <= 0 then fighter.state = Config.States.IDLE end
		applyPhysics(fighter, dt)
		return
	end

	if input.block and fighter.onGround then
		fighter.state = Config.States.BLOCK
		fighter.vx = 0
	elseif fighter.state == Config.States.BLOCK and not input.block then
		fighter.state = Config.States.IDLE
	end

	if fighter.state == Config.States.BLOCK then
		applyPhysics(fighter, dt)
		return
	end

	if input.jump and fighter.onGround then
		fighter.vy = Config.JUMP_FORCE
		fighter.y = fighter.y + 0.1
		fighter.onGround = false
		fighter.state = Config.States.JUMP
	end

	local moving = false
	if input.left then fighter.vx = -Config.MOVE_SPEED; moving = true
	elseif input.right then fighter.vx = Config.MOVE_SPEED; moving = true
	else fighter.vx = 0 end

	if fighter.onGround and not moving and fighter.state ~= Config.States.JUMP then
		fighter.state = Config.States.IDLE
	elseif fighter.onGround and moving and fighter.state ~= Config.States.JUMP then
		fighter.state = Config.States.WALK
	end
	if not fighter.onGround then fighter.state = Config.States.JUMP end

	local function newPress(key)
		return input[key] and not fighter.prevInput[key]
	end

	-- Base attacks
	if newPress("punch") then
		local atk = Config.Attacks.punch
		fighter.state = Config.States.PUNCH
		fighter.stateTimer = atk.startup + atk.active + atk.recovery
		fighter.attackHit = false; fighter.vx = 0
		fireToFighters(match, "attack", { attackType = "punch", attacker = fighter == match.fighters[1] and 1 or 2 })
	elseif newPress("kick") then
		local atk = Config.Attacks.kick
		fighter.state = Config.States.KICK
		fighter.stateTimer = atk.startup + atk.active + atk.recovery
		fighter.attackHit = false; fighter.vx = 0
		fireToFighters(match, "attack", { attackType = "kick", attacker = fighter == match.fighters[1] and 1 or 2 })
	elseif newPress("special") then
		local atk = Config.Attacks.special
		fighter.state = Config.States.SPECIAL
		fighter.stateTimer = atk.startup + atk.active + atk.recovery
		fighter.attackHit = false; fighter.vx = 0
		fireToFighters(match, "attack", { attackType = "special", attacker = fighter == match.fighters[1] and 1 or 2 })
	elseif newPress("ability1") then
		if fighter.equippedAbilities[1] then
			local atk = Config.AbilityAttacks[fighter.equippedAbilities[1]]
			if atk then
				fighter.state = Config.States.ABILITY1
				fighter.stateTimer = atk.startup + atk.active + atk.recovery
				fighter.attackHit = false; fighter.vx = 0
				fireToFighters(match, "attack", { attackType = fighter.equippedAbilities[1], attacker = fighter == match.fighters[1] and 1 or 2 })
				print("[PixelBrawl] ABILITY1 triggered: " .. tostring(fighter.equippedAbilities[1]) .. " timer=" .. tostring(fighter.stateTimer))
			else
				print("[PixelBrawl] ABILITY1 key '" .. tostring(fighter.equippedAbilities[1]) .. "' not found in AbilityAttacks!")
			end
		else
			print("[PixelBrawl] ABILITY1 pressed but equippedAbilities[1] is nil! equippedAbilities = " .. tostring(fighter.equippedAbilities[1]) .. ", " .. tostring(fighter.equippedAbilities[2]))
		end
	elseif newPress("ability2") then
		if fighter.equippedAbilities[2] then
			local atk = Config.AbilityAttacks[fighter.equippedAbilities[2]]
			if atk then
				fighter.state = Config.States.ABILITY2
				fighter.stateTimer = atk.startup + atk.active + atk.recovery
				fighter.attackHit = false; fighter.vx = 0
				fireToFighters(match, "attack", { attackType = fighter.equippedAbilities[2], attacker = fighter == match.fighters[1] and 1 or 2 })
				print("[PixelBrawl] ABILITY2 triggered: " .. tostring(fighter.equippedAbilities[2]) .. " timer=" .. tostring(fighter.stateTimer))
			else
				print("[PixelBrawl] ABILITY2 key '" .. tostring(fighter.equippedAbilities[2]) .. "' not found in AbilityAttacks!")
			end
		else
			print("[PixelBrawl] ABILITY2 pressed but equippedAbilities[2] is nil! equippedAbilities = " .. tostring(fighter.equippedAbilities[1]) .. ", " .. tostring(fighter.equippedAbilities[2]))
		end
	end

	if opponent and fighter.state ~= Config.States.HITSTUN then
		fighter.facingRight = fighter.x < opponent.x
	end

	fighter.prevInput = {}
	for k, v in pairs(input) do fighter.prevInput[k] = v end
	applyPhysics(fighter, dt)
end

local function updateProjectiles(match, dt)
	for i = #match.projectiles, 1, -1 do
		local p = match.projectiles[i]
		p.x = p.x + p.vx * dt
		p.life = p.life - dt
		if p.life <= 0 or p.x < Config.ARENA_MIN_X - 10 or p.x > Config.ARENA_MAX_X + 10 then
			table.remove(match.projectiles, i)
		else
			for _, f in ipairs(match.fighters) do
				if f ~= p.owner and f.state ~= Config.States.KO then
					if math.abs(p.x - f.x) < 6 and math.abs(p.y - f.y - 3) < 6 then
						if f.state == Config.States.BLOCK then
							f.health = f.health - p.damage * Config.BLOCK_REDUCTION
							fireToFighters(match, "blocked", { x = p.x, y = p.y, attackType = "special" })
						else
							f.health = f.health - p.damage
							f.state = Config.States.HITSTUN
							f.stateTimer = p.hitstun
							local dir = p.vx > 0 and 1 or -1
							f.vx = dir * p.knockback; f.vy = 3
							fireToFighters(match, "hit", { x = p.x, y = p.y, attackType = "special" })
						end
						table.remove(match.projectiles, i)
						break
					end
				end
			end
		end
	end
end

local function resetRound(match)
	for i, f in ipairs(match.fighters) do
		f.x = i == 1 and -30 or 30
		f.y = Config.GROUND_Y; f.vx = 0; f.vy = 0
		f.health = Config.MAX_HEALTH; f.state = Config.States.IDLE
		f.stateTimer = 0; f.attackHit = false
		f.facingRight = i == 1; f.onGround = true
		if not f.isBot then
			local char = f.player.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				char.HumanoidRootPart.CFrame = CFrame.new(f.x, Config.GROUND_Y + 3, 0)
				char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
			end
		end
	end
	match.projectiles = {}
	match.roundTimer = Config.ROUND_TIME

	if match.botModel then
		for _, f in ipairs(match.fighters) do
			if f.isBot then
				updateBotModel(match.botModel, f)
			end
		end
	end
end

-- ============================================================
-- UPDATE MATCH
-- ============================================================
local function updateMatch(match, dt)
	for i, f in ipairs(match.fighters) do
		if not f.isBot and not f.player.Parent then
			activeMatches[match.id] = nil
			return
		end
	end

	if match.phase == Config.Phases.COUNTDOWN then
		match.phaseTimer = match.phaseTimer - dt
		if match.phaseTimer <= 0 then
			match.phase = Config.Phases.FIGHTING
			fireToFighters(match, "fight", {})
		end
	elseif match.phase == Config.Phases.FIGHTING then
		match.roundTimer = match.roundTimer - dt
		if match.roundTimer <= 0 then match.roundTimer = 0 end
		local f1 = match.fighters[1]
		local f2 = match.fighters[2]
		updateFighter(f1, f2, dt, match)
		updateFighter(f2, f1, dt, match)
		updateProjectiles(match, dt)

		for _, f in ipairs(match.fighters) do
			if not f.isBot then
				local char = f.player.Character
				if char and char:FindFirstChild("HumanoidRootPart") then
					local targetCF = CFrame.new(f.x, f.y + 3, 0)
					if f.facingRight then
						targetCF = targetCF * CFrame.Angles(0, math.rad(90), 0)
					else
						targetCF = targetCF * CFrame.Angles(0, math.rad(-90), 0)
					end
					char.HumanoidRootPart.CFrame = targetCF
					char.HumanoidRootPart.Velocity = Vector3.new(f.vx, f.vy, 0)
				end
			else
				if match.botModel then
					updateBotModel(match.botModel, f)
				end
			end
		end

		local p1Dead = f1.health <= 0
		local p2Dead = f2.health <= 0
		if p1Dead or p2Dead or match.roundTimer <= 0 then
			if p2Dead or (not p1Dead and f1.health > f2.health) then
				f1.roundWins = f1.roundWins + 1; f2.state = Config.States.KO
			elseif p1Dead or (not p2Dead and f2.health > f1.health) then
				f2.roundWins = f2.roundWins + 1; f1.state = Config.States.KO
			end
			match.phase = Config.Phases.ROUND_END
			match.phaseTimer = Config.ROUND_END_DELAY
			fireToFighters(match, "roundEnd", { p1Wins = f1.roundWins, p2Wins = f2.roundWins, round = match.currentRound })
		end
	elseif match.phase == Config.Phases.ROUND_END then
		match.phaseTimer = match.phaseTimer - dt
		if match.phaseTimer <= 0 then
			local f1 = match.fighters[1]
			local f2 = match.fighters[2]
			if f1.roundWins >= Config.ROUNDS_TO_WIN or f2.roundWins >= Config.ROUNDS_TO_WIN then
				endMatch(match)
			else
				match.currentRound = match.currentRound + 1
				resetRound(match)
				match.phase = Config.Phases.COUNTDOWN
				match.phaseTimer = Config.COUNTDOWN_TIME
				fireToFighters(match, "newRound", { round = match.currentRound })
			end
		end
	end

	if match.phase ~= Config.Phases.MATCH_END then
		local stateData = {
			phase = match.phase, roundTimer = match.roundTimer,
			currentRound = match.currentRound, phaseTimer = match.phaseTimer,
			fighters = {}, projectiles = {},
		}
		for i, f in ipairs(match.fighters) do
			stateData.fighters[i] = {
				x = f.x, y = f.y, health = f.health, state = f.state,
				facingRight = f.facingRight, roundWins = f.roundWins, name = f.player.Name,
			}
		end
		for _, p in ipairs(match.projectiles) do
			table.insert(stateData.projectiles, { x = p.x, y = p.y, vx = p.vx })
		end
		for _, f in ipairs(match.fighters) do
			if not f.isBot and f.player.Parent then
				gameStateEvent:FireClient(f.player, stateData)
			end
		end
	end
end

-- ============================================================
-- START MATCH WITH AI
-- ============================================================
startMatchWithAI = function(player)
	if isInMatch(player) then return end
	createMatch(player, AI_BOT)
	print("[PixelBrawl] Match started: " .. player.Name .. " vs CPU Fighter (difficulty: " .. (playerDifficulty[player.UserId] or "medium") .. ")")
end

-- ============================================================
-- REMOVE FROM PVP QUEUE
-- ============================================================
local function removeFromQueue(player)
	for i, p in ipairs(pvpQueue) do
		if p == player then
			table.remove(pvpQueue, i)
			return true
		end
	end
	return false
end

-- ============================================================
-- DIFFICULTY SELECTION HANDLER (AI only)
-- ============================================================
selectDifficultyEvent.OnServerEvent:Connect(function(player, difficulty)
	if type(difficulty) ~= "string" then return end
	difficulty = string.lower(difficulty)

	if difficulty ~= "easy" and difficulty ~= "medium" and difficulty ~= "hard" then
		difficulty = "medium"
	end
	playerDifficulty[player.UserId] = difficulty
	playerState[player.UserId] = Config.PlayerStates.IN_MATCH
	print("[PixelBrawl] " .. player.Name .. " selected difficulty: " .. difficulty)

	if player.Parent and not isInMatch(player) then
		startMatchWithAI(player)
	end
end)

-- ============================================================
-- SHOP PURCHASE HANDLER
-- ============================================================
shopPurchaseEvent.OnServerEvent:Connect(function(player, abilityKey)
	if type(abilityKey) ~= "string" then return end
	local shopItem = Config.ShopAbilities[abilityKey]
	if not shopItem then
		print("[PixelBrawl] Invalid shop item: " .. abilityKey)
		return
	end

	local uid = player.UserId
	if not playerInventory[uid] then playerInventory[uid] = {} end

	-- Already owned?
	if playerInventory[uid][abilityKey] then
		gameEventEvent:FireClient(player, "shopResult", { success = false, reason = "Already owned!" })
		return
	end

	-- Enough tokens?
	local tokens = playerTokens[uid] or 0
	if tokens < shopItem.cost then
		gameEventEvent:FireClient(player, "shopResult", { success = false, reason = "Not enough tokens!" })
		return
	end

	-- Purchase!
	playerTokens[uid] = tokens - shopItem.cost
	playerInventory[uid][abilityKey] = true
	print("[PixelBrawl] " .. player.Name .. " bought " .. shopItem.name .. " for " .. shopItem.cost .. " tokens")

	gameEventEvent:FireClient(player, "shopResult", { success = true, abilityKey = abilityKey })
	sendPlayerData(player)
end)

-- ============================================================
-- EQUIP ABILITY HANDLER
-- ============================================================
equipAbilityEvent.OnServerEvent:Connect(function(player, abilityKey, slot)
	print("[PixelBrawl] EquipAbility received: player=" .. player.Name .. " abilityKey=" .. tostring(abilityKey) .. " (" .. type(abilityKey) .. ") slot=" .. tostring(slot) .. " (" .. type(slot) .. ")")
	local uid = player.UserId
	if not playerEquipped[uid] then playerEquipped[uid] = { nil, nil } end
	if not playerInventory[uid] then playerInventory[uid] = {} end

	if type(slot) ~= "number" or (slot ~= 1 and slot ~= 2) then
		print("[PixelBrawl] EquipAbility REJECTED: invalid slot type or value")
		return
	end

	-- Unequip
	if abilityKey == nil or abilityKey == "" then
		playerEquipped[uid][slot] = nil
		sendPlayerData(player)
		return
	end

	if type(abilityKey) ~= "string" then return end

	-- Must own it
	if not playerInventory[uid][abilityKey] then return end

	-- Remove from other slot if already equipped there
	if playerEquipped[uid][1] == abilityKey then playerEquipped[uid][1] = nil end
	if playerEquipped[uid][2] == abilityKey then playerEquipped[uid][2] = nil end

	playerEquipped[uid][slot] = abilityKey
	print("[PixelBrawl] " .. player.Name .. " equipped " .. abilityKey .. " to slot " .. slot)
	sendPlayerData(player)
end)

-- ============================================================
-- PVP ZONE ENTRY HANDLER
-- ============================================================
local function handlePvpZoneEntry(player)
	if isInMatch(player) then return end
	if playerState[player.UserId] == Config.PlayerStates.QUEUED then return end

	playerState[player.UserId] = Config.PlayerStates.QUEUED
	removeFromQueue(player)

	local opponent = nil
	for i, p in ipairs(pvpQueue) do
		if p ~= player and p.Parent and not isInMatch(p) then
			opponent = p
			table.remove(pvpQueue, i)
			break
		end
	end

	if opponent then
		playerState[player.UserId] = Config.PlayerStates.IN_MATCH
		playerState[opponent.UserId] = Config.PlayerStates.IN_MATCH
		print("[PixelBrawl] PVP match: " .. player.Name .. " vs " .. opponent.Name)
		createMatch(opponent, player)
	else
		table.insert(pvpQueue, player)
		gameEventEvent:FireClient(player, "queued", {})
		print("[PixelBrawl] " .. player.Name .. " waiting for PVP opponent")
	end
end

-- ============================================================
-- INPUT HANDLER
-- ============================================================
sendInputEvent.OnServerEvent:Connect(function(player, inputData)
	local match, index = getMatchForPlayer(player)
	if not match then return end
	if match.phase ~= Config.Phases.FIGHTING then return end
	local fighter = match.fighters[index]
	if type(inputData) ~= "table" then return end
	fighter.input = {
		left = inputData.left == true, right = inputData.right == true,
		jump = inputData.jump == true, block = inputData.block == true,
		punch = inputData.punch == true, kick = inputData.kick == true,
		special = inputData.special == true,
		ability1 = inputData.ability1 == true, ability2 = inputData.ability2 == true,
	}
end)

-- ============================================================
-- PLAYER JOIN / LEAVE
-- ============================================================
local function setupPlayer(player)
	playerState[player.UserId] = Config.PlayerStates.LOBBY
	playerTokens[player.UserId] = playerTokens[player.UserId] or 0
	playerInventory[player.UserId] = playerInventory[player.UserId] or {}
	playerEquipped[player.UserId] = playerEquipped[player.UserId] or { nil, nil }

	player.CharacterAdded:Connect(function(character)
		task.delay(0.5, function()
			local healthScript = character:FindFirstChild("Health")
			if healthScript then healthScript:Destroy() end
		end)
		character:WaitForChild("HumanoidRootPart")
		if playerState[player.UserId] ~= Config.PlayerStates.IN_MATCH then
			teleportToLobby(player)
			gameEventEvent:FireClient(player, "enterLobby", {})
			sendPlayerData(player)
		end
	end)
end

Players.PlayerAdded:Connect(function(player)
	print("[PixelBrawl] Player joined: " .. player.Name)
	setupPlayer(player)
end)

for _, player in ipairs(Players:GetPlayers()) do
	setupPlayer(player)
	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		teleportToLobby(player)
		task.delay(1, function()
			gameEventEvent:FireClient(player, "enterLobby", {})
			sendPlayerData(player)
		end)
	end
end

Players.PlayerRemoving:Connect(function(player)
	removeFromQueue(player)
	playerState[player.UserId] = nil
	zoneCooldown[player.UserId] = nil
	playerDifficulty[player.UserId] = nil
	playerTokens[player.UserId] = nil
	playerInventory[player.UserId] = nil
	playerEquipped[player.UserId] = nil
end)

-- ============================================================
-- MAIN GAME LOOP
-- ============================================================
RunService.Heartbeat:Connect(function(dt)
	dt = math.min(dt, 1/30)

	-- Zone detection for lobby players
	for _, p in ipairs(Players:GetPlayers()) do
		local state = playerState[p.UserId]
		if state == Config.PlayerStates.LOBBY then
			local char = p.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local pos = hrp.Position
					local cooldownOk = not zoneCooldown[p.UserId] or (tick() - zoneCooldown[p.UserId] > 3)

					-- Check VS BOT zone
					local distBot = (pos - Config.ZONE_VS_BOT).Magnitude
					if distBot < Config.ZONE_RADIUS and cooldownOk then
						zoneCooldown[p.UserId] = tick()
						gameEventEvent:FireClient(p, "enteredBotZone", {})
					end

					-- Check VS FRIEND zone
					local distFriend = (pos - Config.ZONE_VS_FRIEND).Magnitude
					if distFriend < Config.ZONE_RADIUS and cooldownOk then
						zoneCooldown[p.UserId] = tick()
						handlePvpZoneEntry(p)
					end

					-- Check SHOP zone
					local distShop = (pos - Config.ZONE_SHOP).Magnitude
					if distShop < Config.ZONE_RADIUS and cooldownOk then
						zoneCooldown[p.UserId] = tick()
						gameEventEvent:FireClient(p, "enteredShopZone", {})
					end
				end
			end
		elseif state == Config.PlayerStates.QUEUED then
			local char = p.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local dist = (hrp.Position - Config.ZONE_VS_FRIEND).Magnitude
					if dist > Config.ZONE_RADIUS * 2 then
						removeFromQueue(p)
						playerState[p.UserId] = Config.PlayerStates.LOBBY
						gameEventEvent:FireClient(p, "queueCancelled", {})
					end
				end
			end
		end
	end

	-- Update active matches
	for matchId, match in pairs(activeMatches) do
		updateMatch(match, dt)
	end
end)

print("[PixelBrawl] Server loaded! (AI mode + abilities + shop + tokens)")
]]></ProtectedString>
        </Properties>
      </Item>
  </Item>
  <Item class="ServerStorage" referent="RBXF4A234D9">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
  </Item>
  <Item class="StarterGui" referent="RBXF4A234DA">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
      <Item class="LocalScript" referent="RBX00000068">
        <Properties>
          <string name="Name">FightHUD</string>
          <ProtectedString name="Source"><![CDATA[--[[
	FightHUD - Client-side UI for Pixel Brawl
	LOCATION: StarterGui > FightHUD (LocalScript)

	Creates: health bars, timer, round counter, messages,
	lobby banner, bot difficulty popup, queue indicator,
	token display, shop popup, equip panel, ability indicators,
	AND mobile touch controls (D-pad + attack buttons + ability buttons)
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Config = require(ReplicatedStorage:WaitForChild("FightConfig"))
local remotesFolder = ReplicatedStorage:WaitForChild("FightRemotes")
local gameStateEvent = remotesFolder:WaitForChild(Config.Remotes.GAME_STATE)
local gameEventEvent = remotesFolder:WaitForChild(Config.Remotes.GAME_EVENT)
local sendInputEvent = remotesFolder:WaitForChild(Config.Remotes.SEND_INPUT)
local selectDifficultyEvent = remotesFolder:WaitForChild(Config.Remotes.SELECT_DIFFICULTY)
local shopPurchaseEvent = remotesFolder:WaitForChild(Config.Remotes.SHOP_PURCHASE)
local equipAbilityEvent = remotesFolder:WaitForChild(Config.Remotes.EQUIP_ABILITY)

local player = Players.LocalPlayer
local isMobile = UserInputService.TouchEnabled

-- ============================================================
-- PLAYER DATA (synced from server)
-- ============================================================
local myTokens = 0
local myInventory = {}    -- { "dashPunch", "spinKick", ... }
local myEquipped = { nil, nil }  -- { slot1 = abilityKey or nil, slot2 = abilityKey or nil }

-- ============================================================
-- MUSIC & SOUND EFFECTS
-- ============================================================
local SoundService = game:GetService("SoundService")

local function makeSound(name, id, vol, looped, speed)
	local s = Instance.new("Sound")
	s.Name = name
	s.SoundId = "rbxassetid://" .. tostring(id)
	s.Volume = vol or 0.5
	s.Looped = looped or false
	s.PlaybackSpeed = speed or 1
	s.Parent = SoundService
	return s
end

-- MUSIC
local menuMusic = makeSound("MenuMusic", 9043887091, 0.35, true, 1.0)
local battleMusic1 = makeSound("BattleMusic1", 1837779548, 0.5, true, 1.0)
local battleMusic2 = makeSound("BattleMusic2", 1846856152, 0.5, true, 1.0)
local battleMusic3 = makeSound("BattleMusic3", 9038254803, 0.5, true, 1.0)
local battleTracks = { battleMusic1, battleMusic2, battleMusic3 }
local currentBattleTrack = nil

-- SFX
local punchSound = makeSound("PunchSFX", 278061737, 0.5)
local kickSound = makeSound("KickSFX", 138285836, 0.6)
local koSound = makeSound("KOSound", 5765631938, 0.8, false, 0.5)
local winSound = makeSound("WinSound", 5765631938, 0.7, false, 0.7)
local countdownBeep = makeSound("CountdownBeep", 5765631938, 0.4, false, 2)
local fightShout = makeSound("FightShout", 5765631938, 0.9, false, 0.5)
local buySFX = makeSound("BuySFX", 5765631938, 0.6, false, 1.5)
local coinSFX = makeSound("CoinSFX", 5765631938, 0.5, false, 2.0)

local function stopAllMusic()
	menuMusic:Stop()
	for _, track in ipairs(battleTracks) do
		track:Stop()
	end
end

local function playMenuMusic()
	stopAllMusic()
	if not menuMusic.IsPlaying then
		menuMusic:Play()
	end
end

local function playBattleMusic()
	stopAllMusic()
	currentBattleTrack = battleTracks[math.random(1, #battleTracks)]
	currentBattleTrack:Play()
end

-- Start menu music immediately
menuMusic:Play()

-- ============================================================
-- TOUCH INPUT STATE (for mobile)
-- ============================================================
local touchInput = {
	left = false, right = false, jump = false,
	block = false, punch = false, kick = false, special = false,
	ability1 = false, ability2 = false,
}

RunService.Heartbeat:Connect(function()
	if isMobile then
		sendInputEvent:FireServer(touchInput)
	end
end)

-- ============================================================
-- CREATE GUI
-- ============================================================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FightHUD"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = player:WaitForChild("PlayerGui")

local COLOR_RED = Color3.fromRGB(220, 40, 40)
local COLOR_YELLOW = Color3.fromRGB(220, 220, 40)
local COLOR_GREEN = Color3.fromRGB(40, 200, 40)
local COLOR_BLUE = Color3.fromRGB(60, 120, 255)
local COLOR_BG = Color3.fromRGB(30, 30, 30)
local COLOR_WHITE = Color3.fromRGB(255, 255, 255)
local COLOR_GOLD = Color3.fromRGB(255, 215, 0)
local COLOR_DARK = Color3.fromRGB(15, 15, 25)
local COLOR_PURPLE = Color3.fromRGB(130, 50, 200)
local COLOR_ORANGE = Color3.fromRGB(255, 140, 40)
local COLOR_SHOP_BG = Color3.fromRGB(25, 20, 15)
local COLOR_EQUIP_BG = Color3.fromRGB(15, 20, 30)

-- ============================================================
-- HELPERS
-- ============================================================
local function newFrame(props)
	local f = Instance.new("Frame")
	f.BackgroundColor3 = props.color or COLOR_BG
	f.BorderSizePixel = 0
	f.Size = props.size or UDim2.new(0, 100, 0, 20)
	f.Position = props.pos or UDim2.new(0, 0, 0, 0)
	f.AnchorPoint = props.anchor or Vector2.new(0, 0)
	if props.transparency then f.BackgroundTransparency = props.transparency end
	if props.corner then
		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(0, props.corner)
		c.Parent = f
	end
	if props.zindex then f.ZIndex = props.zindex end
	f.Parent = props.parent or screenGui
	return f
end

local function newLabel(props)
	local l = Instance.new("TextLabel")
	l.BackgroundTransparency = 1
	l.Size = props.size or UDim2.new(0, 100, 0, 30)
	l.Position = props.pos or UDim2.new(0, 0, 0, 0)
	l.AnchorPoint = props.anchor or Vector2.new(0, 0)
	l.Text = props.text or ""
	l.TextColor3 = props.color or COLOR_WHITE
	l.TextSize = props.textSize or 18
	l.Font = props.font or Enum.Font.GothamBold
	l.TextXAlignment = props.alignX or Enum.TextXAlignment.Center
	l.TextStrokeTransparency = props.strokeTransparency or 0.5
	l.TextStrokeColor3 = Color3.new(0, 0, 0)
	if props.zindex then l.ZIndex = props.zindex end
	l.Parent = props.parent or screenGui
	return l
end

local function newButton(props)
	local b = Instance.new("TextButton")
	b.Size = props.size or UDim2.new(0, 100, 0, 30)
	b.Position = props.pos or UDim2.new(0, 0, 0, 0)
	b.AnchorPoint = props.anchor or Vector2.new(0, 0)
	b.BackgroundColor3 = props.color or COLOR_BG
	b.BackgroundTransparency = props.transparency or 0
	b.Text = props.text or ""
	b.TextColor3 = props.textColor or COLOR_WHITE
	b.TextSize = props.textSize or 16
	b.Font = props.font or Enum.Font.GothamBold
	b.TextStrokeTransparency = 0.5
	b.TextStrokeColor3 = Color3.new(0, 0, 0)
	b.Active = true
	if props.corner then
		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(0, props.corner)
		c.Parent = b
	end
	b.Parent = props.parent or screenGui
	return b
end

-- ============================================================
-- HUD (health bars, timer, rounds) — shown during fights
-- ============================================================
local hudFrame = newFrame({
	size = UDim2.new(1, 0, 0, 80),
	pos = UDim2.new(0, 0, 0, 0),
	color = Color3.new(0, 0, 0),
	transparency = 0.6,
	parent = screenGui,
})
hudFrame.Name = "HUD"
hudFrame.Visible = false

local p1NameLabel = newLabel({
	size = UDim2.new(0, 200, 0, 20), pos = UDim2.new(0, 20, 0, 5),
	text = "PLAYER 1", color = COLOR_RED, textSize = 14,
	alignX = Enum.TextXAlignment.Left, parent = hudFrame,
})

local p2NameLabel = newLabel({
	size = UDim2.new(0, 200, 0, 20), pos = UDim2.new(1, -20, 0, 5),
	anchor = Vector2.new(1, 0), text = "PLAYER 2", color = COLOR_BLUE,
	textSize = 14, alignX = Enum.TextXAlignment.Right, parent = hudFrame,
})

local p1BarBG = newFrame({
	size = UDim2.new(0.35, 0, 0, 20), pos = UDim2.new(0, 20, 0, 28),
	color = COLOR_BG, corner = 4, parent = hudFrame,
})
local p1BarFill = newFrame({
	size = UDim2.new(1, 0, 1, 0), color = COLOR_GREEN, corner = 4, parent = p1BarBG,
})
local p1Border = Instance.new("UIStroke")
p1Border.Color = COLOR_WHITE; p1Border.Thickness = 1.5; p1Border.Parent = p1BarBG

local p2BarBG = newFrame({
	size = UDim2.new(0.35, 0, 0, 20), pos = UDim2.new(1, -20, 0, 28),
	anchor = Vector2.new(1, 0), color = COLOR_BG, corner = 4, parent = hudFrame,
})
local p2BarFill = newFrame({
	size = UDim2.new(1, 0, 1, 0), pos = UDim2.new(1, 0, 0, 0),
	anchor = Vector2.new(1, 0), color = COLOR_GREEN, corner = 4, parent = p2BarBG,
})
local p2Border = Instance.new("UIStroke")
p2Border.Color = COLOR_WHITE; p2Border.Thickness = 1.5; p2Border.Parent = p2BarBG

local timerLabel = newLabel({
	size = UDim2.new(0, 80, 0, 40), pos = UDim2.new(0.5, 0, 0, 14),
	anchor = Vector2.new(0.5, 0), text = "60", color = COLOR_WHITE,
	textSize = 32, parent = hudFrame,
})

local roundLabel = newLabel({
	size = UDim2.new(0, 200, 0, 18), pos = UDim2.new(0.5, 0, 0, 54),
	anchor = Vector2.new(0.5, 0), text = "ROUND 1", color = COLOR_GOLD,
	textSize = 12, parent = hudFrame,
})

local p1Dots = {}
for i = 1, Config.ROUNDS_TO_WIN do
	local dot = newFrame({
		size = UDim2.new(0, 10, 0, 10), pos = UDim2.new(0, 20 + (i-1)*15, 0, 55),
		color = Color3.fromRGB(60,60,60), corner = 5, parent = hudFrame,
	})
	table.insert(p1Dots, dot)
end

local p2Dots = {}
for i = 1, Config.ROUNDS_TO_WIN do
	local dot = newFrame({
		size = UDim2.new(0, 10, 0, 10), pos = UDim2.new(1, -20-(i-1)*15, 0, 55),
		anchor = Vector2.new(1, 0), color = Color3.fromRGB(60,60,60), corner = 5, parent = hudFrame,
	})
	table.insert(p2Dots, dot)
end

-- ============================================================
-- CENTER MESSAGES (FIGHT!, K.O.!, etc.)
-- ============================================================
local centerLabel = newLabel({
	size = UDim2.new(1, 0, 0, 80), pos = UDim2.new(0.5, 0, 0.4, 0),
	anchor = Vector2.new(0.5, 0.5), text = "", color = COLOR_WHITE,
	textSize = 48, font = Enum.Font.GothamBlack, parent = screenGui,
})
centerLabel.Name = "CenterMessage"

local subLabel = newLabel({
	size = UDim2.new(1, 0, 0, 30), pos = UDim2.new(0.5, 0, 0.48, 0),
	anchor = Vector2.new(0.5, 0.5), text = "", color = COLOR_GOLD,
	textSize = 18, parent = screenGui,
})

-- ============================================================
-- TOKEN DISPLAY (top-right, visible in lobby)
-- ============================================================
local tokenFrame = newFrame({
	size = UDim2.new(0, 160, 0, 40),
	pos = UDim2.new(1, -15, 0, 15),
	anchor = Vector2.new(1, 0),
	color = Color3.fromRGB(30, 25, 10),
	transparency = 0.2,
	corner = 10,
	parent = screenGui,
})
tokenFrame.Name = "TokenDisplay"

local tokenStroke = Instance.new("UIStroke")
tokenStroke.Color = COLOR_GOLD
tokenStroke.Thickness = 2
tokenStroke.Parent = tokenFrame

-- Coin icon (circle)
local coinIcon = newFrame({
	size = UDim2.new(0, 26, 0, 26),
	pos = UDim2.new(0, 10, 0.5, 0),
	anchor = Vector2.new(0, 0.5),
	color = COLOR_GOLD,
	corner = 13,
	parent = tokenFrame,
})
newLabel({
	size = UDim2.new(1, 0, 1, 0),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	text = "$", color = Color3.fromRGB(120, 80, 0), textSize = 16,
	font = Enum.Font.GothamBlack, parent = coinIcon,
})

local tokenLabel = newLabel({
	size = UDim2.new(0, 100, 0, 30),
	pos = UDim2.new(0, 42, 0.5, 0),
	anchor = Vector2.new(0, 0.5),
	text = "0", color = COLOR_GOLD, textSize = 22,
	font = Enum.Font.GothamBlack,
	alignX = Enum.TextXAlignment.Left,
	parent = tokenFrame,
})

local function updateTokenDisplay()
	tokenLabel.Text = tostring(myTokens)
end

-- ============================================================
-- LOBBY BANNER (shown in lobby, no overlay — player walks freely)
-- ============================================================
local lobbyBanner = newFrame({
	size = UDim2.new(0, 500, 0, 50),
	pos = UDim2.new(0.5, 0, 0, 20),
	anchor = Vector2.new(0.5, 0),
	color = Color3.fromRGB(0, 0, 0),
	transparency = 0.5,
	corner = 12,
	parent = screenGui,
})
lobbyBanner.Name = "LobbyBanner"

newLabel({
	size = UDim2.new(1, 0, 1, 0),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	text = "WALK INTO A PORTAL TO FIGHT!",
	color = COLOR_GOLD, textSize = 22,
	font = Enum.Font.GothamBlack,
	parent = lobbyBanner,
})

-- Controls hint below banner
local controlsHint = newLabel({
	size = UDim2.new(0, 500, 0, 20),
	pos = UDim2.new(0.5, 0, 0, 75),
	anchor = Vector2.new(0.5, 0),
	text = isMobile and "Walk to a glowing portal" or "Move: WASD  |  Portals to fight  |  Shop in the back  |  [C] Controls",
	color = Color3.fromRGB(180, 180, 180), textSize = 13,
	parent = screenGui,
})
controlsHint.Name = "ControlsHint"

-- ============================================================
-- CONTROLS PANEL (toggleable with C key or button)
-- ============================================================
local controlsPanel = newFrame({
	size = UDim2.new(0, 360, 0, 340),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	color = Color3.fromRGB(15, 15, 25),
	transparency = 0.02,
	corner = 16,
	parent = screenGui,
	zindex = 12,
})
controlsPanel.Name = "ControlsPanel"
controlsPanel.Visible = false

local controlsPanelStroke = Instance.new("UIStroke")
controlsPanelStroke.Color = COLOR_WHITE
controlsPanelStroke.Thickness = 2
controlsPanelStroke.Parent = controlsPanel

-- Title
newLabel({
	size = UDim2.new(1, 0, 0, 30),
	pos = UDim2.new(0.5, 0, 0, 12),
	anchor = Vector2.new(0.5, 0),
	text = "CONTROLS", color = COLOR_WHITE, textSize = 24,
	font = Enum.Font.GothamBlack, parent = controlsPanel, zindex = 12,
})

-- Helper to make a control row
local function makeControlRow(yPos, keyText, keyColor, actionText)
	-- Key badge
	local keyBadge = newFrame({
		size = UDim2.new(0, 70, 0, 26),
		pos = UDim2.new(0, 25, 0, yPos),
		color = Color3.fromRGB(40, 40, 55),
		corner = 6,
		parent = controlsPanel,
		zindex = 12,
	})
	local badgeStroke = Instance.new("UIStroke")
	badgeStroke.Color = keyColor
	badgeStroke.Thickness = 1.5
	badgeStroke.Parent = keyBadge

	newLabel({
		size = UDim2.new(1, 0, 1, 0),
		pos = UDim2.new(0.5, 0, 0.5, 0),
		anchor = Vector2.new(0.5, 0.5),
		text = keyText, color = keyColor, textSize = 13,
		font = Enum.Font.GothamBlack,
		parent = keyBadge, zindex = 12,
	})

	-- Action label
	newLabel({
		size = UDim2.new(0, 220, 0, 26),
		pos = UDim2.new(0, 105, 0, yPos),
		text = actionText, color = Color3.fromRGB(200, 200, 200), textSize = 14,
		font = Enum.Font.GothamBold,
		alignX = Enum.TextXAlignment.Left,
		parent = controlsPanel, zindex = 12,
	})
end

-- Section: Movement
newLabel({
	size = UDim2.new(1, 0, 0, 18),
	pos = UDim2.new(0, 25, 0, 48),
	text = "MOVEMENT", color = COLOR_GOLD, textSize = 11,
	font = Enum.Font.GothamBlack,
	alignX = Enum.TextXAlignment.Left,
	parent = controlsPanel, zindex = 12,
})
makeControlRow(68, "A / D", Color3.fromRGB(150, 150, 200), "Move Left / Right")
makeControlRow(98, "W / Space", Color3.fromRGB(150, 200, 150), "Jump")
makeControlRow(128, "S", Color3.fromRGB(200, 200, 100), "Block")

-- Section: Attacks
newLabel({
	size = UDim2.new(1, 0, 0, 18),
	pos = UDim2.new(0, 25, 0, 162),
	text = "ATTACKS", color = COLOR_RED, textSize = 11,
	font = Enum.Font.GothamBlack,
	alignX = Enum.TextXAlignment.Left,
	parent = controlsPanel, zindex = 12,
})
makeControlRow(182, "F / Q", COLOR_RED, "Punch (fast, light)")
makeControlRow(212, "G / E", COLOR_BLUE, "Kick (slow, heavy)")
makeControlRow(242, "H / R", COLOR_ORANGE, "Special (projectile)")

-- Section: Abilities
newLabel({
	size = UDim2.new(1, 0, 0, 18),
	pos = UDim2.new(0, 25, 0, 276),
	text = "ABILITIES (equip in lobby)", color = COLOR_PURPLE, textSize = 11,
	font = Enum.Font.GothamBlack,
	alignX = Enum.TextXAlignment.Left,
	parent = controlsPanel, zindex = 12,
})
makeControlRow(296, "Z / 1", Color3.fromRGB(255, 160, 60), "Ability Slot 1")
makeControlRow(326, "X / 2", Color3.fromRGB(60, 160, 255), "Ability Slot 2")

-- Divider line
local divider = newFrame({
	size = UDim2.new(0.85, 0, 0, 1),
	pos = UDim2.new(0.5, 0, 0, 156),
	anchor = Vector2.new(0.5, 0),
	color = Color3.fromRGB(60, 60, 80),
	parent = controlsPanel,
	zindex = 12,
})
local divider2 = newFrame({
	size = UDim2.new(0.85, 0, 0, 1),
	pos = UDim2.new(0.5, 0, 0, 270),
	anchor = Vector2.new(0.5, 0),
	color = Color3.fromRGB(60, 60, 80),
	parent = controlsPanel,
	zindex = 12,
})

-- Extra info: Tab + Equip
newLabel({
	size = UDim2.new(0.9, 0, 0, 16),
	pos = UDim2.new(0.5, 0, 1, -8),
	anchor = Vector2.new(0.5, 1),
	text = "[Tab] Equip Menu  |  [C] Close",
	color = Color3.fromRGB(120, 120, 140), textSize = 11,
	parent = controlsPanel, zindex = 12,
})

-- Close controls panel on click
local controlsCloseBtn = newButton({
	size = UDim2.new(0, 28, 0, 28),
	pos = UDim2.new(1, -10, 0, 10),
	anchor = Vector2.new(1, 0),
	color = Color3.fromRGB(80, 30, 30),
	text = "X", textColor = COLOR_WHITE,
	textSize = 14, corner = 14,
	parent = controlsPanel,
})
controlsCloseBtn.ZIndex = 12
controlsCloseBtn.MouseButton1Click:Connect(function()
	controlsPanel.Visible = false
end)

-- Controls button in lobby (bottom-left, next to equip)
local controlsOpenBtn = newButton({
	size = UDim2.new(0, 50, 0, 38),
	pos = UDim2.new(0, 155, 1, -60),
	anchor = Vector2.new(0, 1),
	color = Color3.fromRGB(60, 60, 80),
	transparency = 0.15,
	text = "[C]", textColor = COLOR_WHITE,
	textSize = 15, corner = 10, font = Enum.Font.GothamBlack,
	parent = screenGui,
})
controlsOpenBtn.Name = "ControlsOpenBtn"
controlsOpenBtn.Visible = false

local controlsOpenStroke = Instance.new("UIStroke")
controlsOpenStroke.Color = COLOR_WHITE
controlsOpenStroke.Thickness = 1.5
controlsOpenStroke.Transparency = 0.5
controlsOpenStroke.Parent = controlsOpenBtn

controlsOpenBtn.MouseButton1Click:Connect(function()
	controlsPanel.Visible = not controlsPanel.Visible
	shopPopup.Visible = false
	equipPanel.Visible = false
end)

-- C key to toggle controls panel
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.C and controlsOpenBtn.Visible then
		controlsPanel.Visible = not controlsPanel.Visible
		if controlsPanel.Visible then
			shopPopup.Visible = false
			equipPanel.Visible = false
		end
	end
end)

-- ============================================================
-- BOT DIFFICULTY POPUP (shown when player enters VS BOT zone)
-- ============================================================
local botPopup = newFrame({
	size = UDim2.new(0, 340, 0, 260),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	color = Color3.fromRGB(20, 20, 35),
	transparency = 0.05,
	corner = 16,
	parent = screenGui,
})
botPopup.Name = "BotDifficultyPopup"
botPopup.Visible = false

local botPopupStroke = Instance.new("UIStroke")
botPopupStroke.Color = COLOR_RED
botPopupStroke.Thickness = 2.5
botPopupStroke.Parent = botPopup

newLabel({
	size = UDim2.new(1, 0, 0, 30),
	pos = UDim2.new(0.5, 0, 0, 15),
	anchor = Vector2.new(0.5, 0),
	text = "VS CPU", color = COLOR_RED, textSize = 26,
	font = Enum.Font.GothamBlack, parent = botPopup,
})

newLabel({
	size = UDim2.new(1, 0, 0, 20),
	pos = UDim2.new(0.5, 0, 0, 48),
	anchor = Vector2.new(0.5, 0),
	text = "Choose Difficulty:", color = COLOR_WHITE, textSize = 16,
	parent = botPopup,
})

local function makeDifficultyButton(label, color, yOffset, value)
	local btn = Instance.new("TextButton")
	btn.Name = value
	btn.Size = UDim2.new(0.8, 0, 0, 40)
	btn.Position = UDim2.new(0.5, 0, 0, yOffset)
	btn.AnchorPoint = Vector2.new(0.5, 0)
	btn.BackgroundColor3 = color
	btn.BackgroundTransparency = 0.15
	btn.Text = label
	btn.TextColor3 = COLOR_WHITE
	btn.TextSize = 20
	btn.Font = Enum.Font.GothamBlack
	btn.TextStrokeTransparency = 0.3
	btn.TextStrokeColor3 = Color3.new(0, 0, 0)
	btn.Parent = botPopup
	btn.Active = true

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = btn

	local stroke = Instance.new("UIStroke")
	stroke.Color = COLOR_WHITE
	stroke.Thickness = 1.5
	stroke.Transparency = 0.5
	stroke.Parent = btn

	-- Show token reward on difficulty buttons
	local reward = Config.TOKEN_REWARDS[value] or 0
	if reward > 0 then
		local rewardLabel = Instance.new("TextLabel")
		rewardLabel.Size = UDim2.new(0, 80, 0, 20)
		rewardLabel.Position = UDim2.new(1, -5, 0.5, 0)
		rewardLabel.AnchorPoint = Vector2.new(1, 0.5)
		rewardLabel.BackgroundTransparency = 1
		rewardLabel.Text = "+" .. reward .. " $"
		rewardLabel.TextColor3 = COLOR_GOLD
		rewardLabel.TextSize = 13
		rewardLabel.Font = Enum.Font.GothamBold
		rewardLabel.TextXAlignment = Enum.TextXAlignment.Right
		rewardLabel.TextStrokeTransparency = 0.3
		rewardLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
		rewardLabel.Parent = btn
	end

	btn.MouseButton1Click:Connect(function()
		print("[PixelBrawl] Selected difficulty: " .. value)
		selectDifficultyEvent:FireServer(value)
		botPopup.Visible = false
	end)

	btn.MouseEnter:Connect(function() btn.BackgroundTransparency = 0 end)
	btn.MouseLeave:Connect(function() btn.BackgroundTransparency = 0.15 end)

	return btn
end

makeDifficultyButton("EASY", Color3.fromRGB(40, 160, 40), 78, "easy")
makeDifficultyButton("MEDIUM", Color3.fromRGB(200, 160, 30), 125, "medium")
makeDifficultyButton("HARD", Color3.fromRGB(200, 40, 40), 172, "hard")

-- Cancel button
local cancelBtn = Instance.new("TextButton")
cancelBtn.Name = "Cancel"
cancelBtn.Size = UDim2.new(0.5, 0, 0, 28)
cancelBtn.Position = UDim2.new(0.5, 0, 0, 222)
cancelBtn.AnchorPoint = Vector2.new(0.5, 0)
cancelBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
cancelBtn.BackgroundTransparency = 0.3
cancelBtn.Text = "CANCEL"
cancelBtn.TextColor3 = Color3.fromRGB(180, 180, 180)
cancelBtn.TextSize = 14
cancelBtn.Font = Enum.Font.GothamBold
cancelBtn.Parent = botPopup

local cancelCorner = Instance.new("UICorner")
cancelCorner.CornerRadius = UDim.new(0, 8)
cancelCorner.Parent = cancelBtn

cancelBtn.MouseButton1Click:Connect(function()
	botPopup.Visible = false
end)

-- ============================================================
-- PVP QUEUE INDICATOR (shown when waiting for opponent)
-- ============================================================
local queueIndicator = newFrame({
	size = UDim2.new(0, 340, 0, 80),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	color = Color3.fromRGB(20, 15, 35),
	transparency = 0.05,
	corner = 16,
	parent = screenGui,
})
queueIndicator.Name = "QueueIndicator"
queueIndicator.Visible = false

local queueStroke = Instance.new("UIStroke")
queueStroke.Color = COLOR_PURPLE
queueStroke.Thickness = 2.5
queueStroke.Parent = queueIndicator

local queueLabel = newLabel({
	size = UDim2.new(1, 0, 0, 30),
	pos = UDim2.new(0.5, 0, 0, 12),
	anchor = Vector2.new(0.5, 0),
	text = "VS FRIEND", color = COLOR_PURPLE, textSize = 22,
	font = Enum.Font.GothamBlack, parent = queueIndicator,
})

local queueStatus = newLabel({
	size = UDim2.new(1, 0, 0, 20),
	pos = UDim2.new(0.5, 0, 0, 48),
	anchor = Vector2.new(0.5, 0),
	text = "Waiting for opponent...", color = COLOR_WHITE, textSize = 16,
	parent = queueIndicator,
})

-- Animate dots on queue status
local queueDots = 0
local queueAnimRunning = false

local function startQueueAnimation()
	queueAnimRunning = true
	task.spawn(function()
		while queueAnimRunning and queueIndicator.Visible do
			queueDots = (queueDots % 3) + 1
			queueStatus.Text = "Waiting for opponent" .. string.rep(".", queueDots)
			task.wait(0.5)
		end
	end)
end

local function stopQueueAnimation()
	queueAnimRunning = false
end

-- ============================================================
-- SHOP POPUP (shown when player enters shop zone)
-- ============================================================
local shopPopup = newFrame({
	size = UDim2.new(0, 420, 0, 440),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	color = COLOR_SHOP_BG,
	transparency = 0.02,
	corner = 16,
	parent = screenGui,
	zindex = 10,
})
shopPopup.Name = "ShopPopup"
shopPopup.Visible = false

local shopStroke = Instance.new("UIStroke")
shopStroke.Color = COLOR_GOLD
shopStroke.Thickness = 2.5
shopStroke.Parent = shopPopup

-- Shop title
newLabel({
	size = UDim2.new(1, 0, 0, 35),
	pos = UDim2.new(0.5, 0, 0, 12),
	anchor = Vector2.new(0.5, 0),
	text = "ABILITY SHOP", color = COLOR_GOLD, textSize = 26,
	font = Enum.Font.GothamBlack, parent = shopPopup, zindex = 10,
})

-- Token display inside shop
local shopTokenLabel = newLabel({
	size = UDim2.new(1, 0, 0, 20),
	pos = UDim2.new(0.5, 0, 0, 48),
	anchor = Vector2.new(0.5, 0),
	text = "Your Tokens: 0", color = COLOR_GOLD, textSize = 15,
	font = Enum.Font.GothamBold, parent = shopPopup, zindex = 10,
})

-- Shop item list
local shopScrollFrame = Instance.new("ScrollingFrame")
shopScrollFrame.Size = UDim2.new(0.92, 0, 0, 310)
shopScrollFrame.Position = UDim2.new(0.5, 0, 0, 75)
shopScrollFrame.AnchorPoint = Vector2.new(0.5, 0)
shopScrollFrame.BackgroundTransparency = 1
shopScrollFrame.BorderSizePixel = 0
shopScrollFrame.ScrollBarThickness = 4
shopScrollFrame.ScrollBarImageColor3 = COLOR_GOLD
shopScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- auto-set
shopScrollFrame.ZIndex = 10
shopScrollFrame.Parent = shopPopup

local shopListLayout = Instance.new("UIListLayout")
shopListLayout.SortOrder = Enum.SortOrder.LayoutOrder
shopListLayout.Padding = UDim.new(0, 6)
shopListLayout.Parent = shopScrollFrame

-- Table to hold shop item frames for updating
local shopItemButtons = {}

local function buildShopItems()
	-- Clear old items
	for _, item in ipairs(shopItemButtons) do
		if item.frame then item.frame:Destroy() end
	end
	shopItemButtons = {}

	for displayOrder, abilityKey in ipairs(Config.ShopAbilityOrder) do
		local abilityData = Config.ShopAbilities[abilityKey]
		if not abilityData then continue end

		local owned = false
		for _, inv in ipairs(myInventory) do
			if inv == abilityKey then
				owned = true
				break
			end
		end

		local itemFrame = newFrame({
			size = UDim2.new(1, 0, 0, 56),
			color = Color3.fromRGB(35, 30, 22),
			corner = 8,
			parent = shopScrollFrame,
			zindex = 10,
		})
		itemFrame.LayoutOrder = displayOrder

		local itemStroke = Instance.new("UIStroke")
		itemStroke.Color = abilityData.color
		itemStroke.Thickness = 1.5
		itemStroke.Transparency = 0.3
		itemStroke.Parent = itemFrame

		-- Color bar on left
		local colorBar = newFrame({
			size = UDim2.new(0, 5, 0.8, 0),
			pos = UDim2.new(0, 5, 0.5, 0),
			anchor = Vector2.new(0, 0.5),
			color = abilityData.color,
			corner = 2,
			parent = itemFrame,
			zindex = 10,
		})

		-- Ability name
		newLabel({
			size = UDim2.new(0, 180, 0, 22),
			pos = UDim2.new(0, 18, 0, 4),
			text = abilityData.name, color = COLOR_WHITE, textSize = 16,
			font = Enum.Font.GothamBlack,
			alignX = Enum.TextXAlignment.Left,
			parent = itemFrame, zindex = 10,
		})

		-- Description
		newLabel({
			size = UDim2.new(0, 230, 0, 18),
			pos = UDim2.new(0, 18, 0, 28),
			text = abilityData.description, color = Color3.fromRGB(170, 170, 170), textSize = 11,
			font = Enum.Font.Gotham,
			alignX = Enum.TextXAlignment.Left,
			parent = itemFrame, zindex = 10,
		})

		-- Buy/Owned button
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 90, 0, 34)
		btn.Position = UDim2.new(1, -10, 0.5, 0)
		btn.AnchorPoint = Vector2.new(1, 0.5)
		btn.Font = Enum.Font.GothamBlack
		btn.TextStrokeTransparency = 0.3
		btn.TextStrokeColor3 = Color3.new(0, 0, 0)
		btn.Active = true
		btn.ZIndex = 10
		btn.Parent = itemFrame

		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 8)
		btnCorner.Parent = btn

		if owned then
			btn.Text = "OWNED"
			btn.BackgroundColor3 = Color3.fromRGB(50, 70, 50)
			btn.TextColor3 = COLOR_GREEN
			btn.TextSize = 13
			btn.BackgroundTransparency = 0.3
		else
			btn.Text = "$" .. abilityData.cost
			btn.BackgroundColor3 = COLOR_GOLD
			btn.TextColor3 = Color3.fromRGB(40, 30, 0)
			btn.TextSize = 16
			btn.BackgroundTransparency = 0.1

			local canAfford = myTokens >= abilityData.cost
			if not canAfford then
				btn.BackgroundColor3 = Color3.fromRGB(80, 60, 30)
				btn.TextColor3 = Color3.fromRGB(120, 100, 60)
				btn.BackgroundTransparency = 0.4
			end

			btn.MouseButton1Click:Connect(function()
				print("[PixelBrawl] Attempting to buy: " .. abilityKey)
				shopPurchaseEvent:FireServer(abilityKey)
			end)

			btn.MouseEnter:Connect(function()
				if myTokens >= abilityData.cost then
					btn.BackgroundTransparency = 0
				end
			end)
			btn.MouseLeave:Connect(function()
				if myTokens >= abilityData.cost then
					btn.BackgroundTransparency = 0.1
				end
			end)
		end

		table.insert(shopItemButtons, {
			frame = itemFrame,
			key = abilityKey,
			btn = btn,
		})
	end

	-- Update canvas size
	shopScrollFrame.CanvasSize = UDim2.new(0, 0, 0, shopListLayout.AbsoluteContentSize.Y + 10)
end

-- Shop close button
local shopCloseBtn = newButton({
	size = UDim2.new(0.6, 0, 0, 32),
	pos = UDim2.new(0.5, 0, 1, -12),
	anchor = Vector2.new(0.5, 1),
	color = Color3.fromRGB(80, 80, 80),
	transparency = 0.2,
	text = "CLOSE", textColor = Color3.fromRGB(200, 200, 200),
	textSize = 14, corner = 8,
	parent = shopPopup,
})
shopCloseBtn.ZIndex = 10

shopCloseBtn.MouseButton1Click:Connect(function()
	shopPopup.Visible = false
end)

-- ============================================================
-- EQUIP PANEL (shown when player clicks equip from lobby)
-- ============================================================
local equipPanel = newFrame({
	size = UDim2.new(0, 400, 0, 380),
	pos = UDim2.new(0.5, 0, 0.5, 0),
	anchor = Vector2.new(0.5, 0.5),
	color = COLOR_EQUIP_BG,
	transparency = 0.02,
	corner = 16,
	parent = screenGui,
	zindex = 10,
})
equipPanel.Name = "EquipPanel"
equipPanel.Visible = false

local equipStroke = Instance.new("UIStroke")
equipStroke.Color = COLOR_BLUE
equipStroke.Thickness = 2.5
equipStroke.Parent = equipPanel

newLabel({
	size = UDim2.new(1, 0, 0, 30),
	pos = UDim2.new(0.5, 0, 0, 12),
	anchor = Vector2.new(0.5, 0),
	text = "EQUIP ABILITIES", color = COLOR_BLUE, textSize = 24,
	font = Enum.Font.GothamBlack, parent = equipPanel, zindex = 10,
})

-- Slot indicators
local slotFrames = {}
for slotIdx = 1, 2 do
	local slotFrame = newFrame({
		size = UDim2.new(0.44, 0, 0, 60),
		pos = UDim2.new(slotIdx == 1 and 0.03 or 0.53, 0, 0, 48),
		color = Color3.fromRGB(25, 30, 45),
		corner = 10,
		parent = equipPanel,
		zindex = 10,
	})

	local slotStroke = Instance.new("UIStroke")
	slotStroke.Color = Color3.fromRGB(80, 100, 140)
	slotStroke.Thickness = 1.5
	slotStroke.Parent = slotFrame

	local keyLabel = newLabel({
		size = UDim2.new(0, 30, 0, 20),
		pos = UDim2.new(0, 8, 0, 5),
		text = slotIdx == 1 and "[Z]" or "[X]", color = COLOR_GOLD, textSize = 12,
		font = Enum.Font.GothamBlack,
		alignX = Enum.TextXAlignment.Left,
		parent = slotFrame, zindex = 10,
	})

	local slotTitle = newLabel({
		size = UDim2.new(0, 60, 0, 20),
		pos = UDim2.new(0, 40, 0, 5),
		text = "SLOT " .. slotIdx, color = Color3.fromRGB(150, 150, 180), textSize = 11,
		alignX = Enum.TextXAlignment.Left,
		parent = slotFrame, zindex = 10,
	})

	local slotAbilityLabel = newLabel({
		size = UDim2.new(0.9, 0, 0, 24),
		pos = UDim2.new(0.5, 0, 0, 28),
		anchor = Vector2.new(0.5, 0),
		text = "- Empty -", color = Color3.fromRGB(100, 100, 120), textSize = 14,
		font = Enum.Font.GothamBold,
		parent = slotFrame, zindex = 10,
	})

	slotFrames[slotIdx] = {
		frame = slotFrame,
		abilityLabel = slotAbilityLabel,
		stroke = slotStroke,
	}
end

-- Owned abilities list for equipping
local equipScrollFrame = Instance.new("ScrollingFrame")
equipScrollFrame.Size = UDim2.new(0.92, 0, 0, 200)
equipScrollFrame.Position = UDim2.new(0.5, 0, 0, 120)
equipScrollFrame.AnchorPoint = Vector2.new(0.5, 0)
equipScrollFrame.BackgroundTransparency = 1
equipScrollFrame.BorderSizePixel = 0
equipScrollFrame.ScrollBarThickness = 4
equipScrollFrame.ScrollBarImageColor3 = COLOR_BLUE
equipScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
equipScrollFrame.ZIndex = 10
equipScrollFrame.Parent = equipPanel

local equipListLayout = Instance.new("UIListLayout")
equipListLayout.SortOrder = Enum.SortOrder.LayoutOrder
equipListLayout.Padding = UDim.new(0, 5)
equipListLayout.Parent = equipScrollFrame

local function updateEquipSlotDisplay()
	for slotIdx = 1, 2 do
		local key = myEquipped[slotIdx]
		local sf = slotFrames[slotIdx]
		if key and Config.ShopAbilities[key] then
			sf.abilityLabel.Text = Config.ShopAbilities[key].name
			sf.abilityLabel.TextColor3 = Config.ShopAbilities[key].color
			sf.stroke.Color = Config.ShopAbilities[key].color
		else
			sf.abilityLabel.Text = "- Empty -"
			sf.abilityLabel.TextColor3 = Color3.fromRGB(100, 100, 120)
			sf.stroke.Color = Color3.fromRGB(80, 100, 140)
		end
	end
end

local function buildEquipList()
	-- Clear old items
	for _, child in ipairs(equipScrollFrame:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	updateEquipSlotDisplay()

	if #myInventory == 0 then
		newLabel({
			size = UDim2.new(1, 0, 0, 40),
			pos = UDim2.new(0.5, 0, 0, 20),
			anchor = Vector2.new(0.5, 0),
			text = "No abilities owned yet!\nVisit the SHOP to buy some.",
			color = Color3.fromRGB(140, 140, 140), textSize = 14,
			parent = equipScrollFrame, zindex = 10,
		})
		equipScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 80)
		return
	end

	for i, abilityKey in ipairs(myInventory) do
		local abilityData = Config.ShopAbilities[abilityKey]
		if not abilityData then continue end

		-- Check if already equipped
		local equippedInSlot = nil
		for s = 1, 2 do
			if myEquipped[s] == abilityKey then
				equippedInSlot = s
				break
			end
		end

		local itemFrame = newFrame({
			size = UDim2.new(1, 0, 0, 48),
			color = Color3.fromRGB(30, 35, 50),
			corner = 8,
			parent = equipScrollFrame,
			zindex = 10,
		})
		itemFrame.LayoutOrder = i

		-- Color bar
		newFrame({
			size = UDim2.new(0, 4, 0.7, 0),
			pos = UDim2.new(0, 6, 0.5, 0),
			anchor = Vector2.new(0, 0.5),
			color = abilityData.color,
			corner = 2,
			parent = itemFrame, zindex = 10,
		})

		-- Name
		newLabel({
			size = UDim2.new(0, 150, 0, 24),
			pos = UDim2.new(0, 18, 0.5, 0),
			anchor = Vector2.new(0, 0.5),
			text = abilityData.name, color = COLOR_WHITE, textSize = 15,
			font = Enum.Font.GothamBold,
			alignX = Enum.TextXAlignment.Left,
			parent = itemFrame, zindex = 10,
		})

		if equippedInSlot then
			-- Show which slot
			local slotLabel = newLabel({
				size = UDim2.new(0, 80, 0, 24),
				pos = UDim2.new(1, -10, 0.5, 0),
				anchor = Vector2.new(1, 0.5),
				text = "SLOT " .. equippedInSlot,
				color = abilityData.color, textSize = 13,
				font = Enum.Font.GothamBlack,
				parent = itemFrame, zindex = 10,
			})
		else
			-- Slot 1 button
			local s1Btn = newButton({
				size = UDim2.new(0, 55, 0, 30),
				pos = UDim2.new(1, -125, 0.5, 0),
				anchor = Vector2.new(0, 0.5),
				color = Color3.fromRGB(50, 60, 90),
				text = "Slot 1", textColor = COLOR_WHITE,
				textSize = 12, corner = 6,
				parent = itemFrame,
			})
			s1Btn.ZIndex = 10
			s1Btn.MouseButton1Click:Connect(function()
				equipAbilityEvent:FireServer(abilityKey, 1)
			end)

			-- Slot 2 button
			local s2Btn = newButton({
				size = UDim2.new(0, 55, 0, 30),
				pos = UDim2.new(1, -62, 0.5, 0),
				anchor = Vector2.new(0, 0.5),
				color = Color3.fromRGB(50, 60, 90),
				text = "Slot 2", textColor = COLOR_WHITE,
				textSize = 12, corner = 6,
				parent = itemFrame,
			})
			s2Btn.ZIndex = 10
			s2Btn.MouseButton1Click:Connect(function()
				equipAbilityEvent:FireServer(abilityKey, 2)
			end)
		end
	end

	equipScrollFrame.CanvasSize = UDim2.new(0, 0, 0, equipListLayout.AbsoluteContentSize.Y + 10)
end

-- Equip close button
local equipCloseBtn = newButton({
	size = UDim2.new(0.6, 0, 0, 32),
	pos = UDim2.new(0.5, 0, 1, -12),
	anchor = Vector2.new(0.5, 1),
	color = Color3.fromRGB(80, 80, 80),
	transparency = 0.2,
	text = "CLOSE", textColor = Color3.fromRGB(200, 200, 200),
	textSize = 14, corner = 8,
	parent = equipPanel,
})
equipCloseBtn.ZIndex = 10

equipCloseBtn.MouseButton1Click:Connect(function()
	equipPanel.Visible = false
end)

-- ============================================================
-- EQUIP BUTTON (small button in lobby, bottom-left area)
-- ============================================================
local equipOpenBtn = newButton({
	size = UDim2.new(0, 130, 0, 38),
	pos = UDim2.new(0, 15, 1, -60),
	anchor = Vector2.new(0, 1),
	color = COLOR_BLUE,
	transparency = 0.15,
	text = "EQUIP [Tab]", textColor = COLOR_WHITE,
	textSize = 15, corner = 10, font = Enum.Font.GothamBlack,
	parent = screenGui,
})
equipOpenBtn.Name = "EquipOpenBtn"
equipOpenBtn.Visible = false

local equipOpenStroke = Instance.new("UIStroke")
equipOpenStroke.Color = COLOR_WHITE
equipOpenStroke.Thickness = 1.5
equipOpenStroke.Transparency = 0.5
equipOpenStroke.Parent = equipOpenBtn

equipOpenBtn.MouseButton1Click:Connect(function()
	if equipPanel.Visible then
		equipPanel.Visible = false
	else
		buildEquipList()
		equipPanel.Visible = true
		shopPopup.Visible = false
	end
end)

-- Tab key to toggle equip panel
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.Tab and equipOpenBtn.Visible then
		if equipPanel.Visible then
			equipPanel.Visible = false
		else
			buildEquipList()
			equipPanel.Visible = true
			shopPopup.Visible = false
		end
	end
end)

-- ============================================================
-- ABILITY INDICATORS (shown during fight, bottom-center)
-- ============================================================
local abilityIndicatorFrame = newFrame({
	size = UDim2.new(0, 200, 0, 50),
	pos = UDim2.new(0.5, 0, 1, -15),
	anchor = Vector2.new(0.5, 1),
	color = Color3.new(0, 0, 0),
	transparency = 0.7,
	corner = 10,
	parent = screenGui,
})
abilityIndicatorFrame.Name = "AbilityIndicators"
abilityIndicatorFrame.Visible = false

local abilitySlotLabels = {}
for slotIdx = 1, 2 do
	local slotBG = newFrame({
		size = UDim2.new(0, 85, 0, 36),
		pos = UDim2.new(0, slotIdx == 1 and 10 or 105, 0.5, 0),
		anchor = Vector2.new(0, 0.5),
		color = Color3.fromRGB(30, 30, 40),
		corner = 6,
		parent = abilityIndicatorFrame,
	})

	local slotKey = newLabel({
		size = UDim2.new(0, 22, 0, 22),
		pos = UDim2.new(0, 4, 0.5, 0),
		anchor = Vector2.new(0, 0.5),
		text = slotIdx == 1 and "Z" or "X", color = COLOR_GOLD, textSize = 12,
		font = Enum.Font.GothamBlack, parent = slotBG,
	})

	local abilityName = newLabel({
		size = UDim2.new(0, 55, 0, 20),
		pos = UDim2.new(0, 28, 0.5, 0),
		anchor = Vector2.new(0, 0.5),
		text = "-", color = COLOR_WHITE, textSize = 10,
		font = Enum.Font.GothamBold,
		alignX = Enum.TextXAlignment.Left,
		parent = slotBG,
	})

	abilitySlotLabels[slotIdx] = {
		bg = slotBG,
		nameLabel = abilityName,
	}
end

local function updateAbilityIndicators()
	local hasAny = false
	for slotIdx = 1, 2 do
		local key = myEquipped[slotIdx]
		local slot = abilitySlotLabels[slotIdx]
		if key and Config.ShopAbilities[key] then
			slot.nameLabel.Text = Config.ShopAbilities[key].name
			slot.nameLabel.TextColor3 = Config.ShopAbilities[key].color
			slot.bg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
			hasAny = true
		else
			slot.nameLabel.Text = "-"
			slot.nameLabel.TextColor3 = Color3.fromRGB(80, 80, 80)
			slot.bg.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
		end
	end
	return hasAny
end

-- ============================================================
-- FLOATING TOKEN REWARD MESSAGE
-- ============================================================
local function showTokenReward(amount)
	coinSFX:Play()
	local floatLabel = Instance.new("TextLabel")
	floatLabel.Size = UDim2.new(0, 200, 0, 40)
	floatLabel.Position = UDim2.new(0.5, 0, 0.55, 0)
	floatLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	floatLabel.BackgroundTransparency = 1
	floatLabel.Text = "+" .. amount .. " TOKENS!"
	floatLabel.TextColor3 = COLOR_GOLD
	floatLabel.TextSize = 28
	floatLabel.Font = Enum.Font.GothamBlack
	floatLabel.TextStrokeTransparency = 0.2
	floatLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	floatLabel.Parent = screenGui

	-- Float up and fade out
	local tweenUp = TweenService:Create(floatLabel, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 0, 0.4, 0),
		TextTransparency = 1,
		TextStrokeTransparency = 1,
	})
	tweenUp:Play()
	tweenUp.Completed:Connect(function()
		floatLabel:Destroy()
	end)
end

-- ============================================================
-- SHOP RESULT MESSAGE (purchase feedback)
-- ============================================================
local function showShopResult(success, msg)
	if success then
		buySFX:Play()
	end

	-- Flash message on shop popup
	local flashLabel = Instance.new("TextLabel")
	flashLabel.Size = UDim2.new(0.9, 0, 0, 24)
	flashLabel.Position = UDim2.new(0.5, 0, 1, -48)
	flashLabel.AnchorPoint = Vector2.new(0.5, 1)
	flashLabel.BackgroundTransparency = 1
	flashLabel.Text = msg or (success and "Purchase successful!" or "Purchase failed")
	flashLabel.TextColor3 = success and COLOR_GREEN or COLOR_RED
	flashLabel.TextSize = 14
	flashLabel.Font = Enum.Font.GothamBold
	flashLabel.TextStrokeTransparency = 0.3
	flashLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	flashLabel.ZIndex = 11
	flashLabel.Parent = shopPopup

	task.delay(2.5, function()
		if flashLabel.Parent then flashLabel:Destroy() end
	end)
end

-- ============================================================
-- MOBILE TOUCH CONTROLS
-- ============================================================
local touchFrame = nil

if isMobile then
	touchFrame = Instance.new("Frame")
	touchFrame.Name = "TouchControls"
	touchFrame.Size = UDim2.new(1, 0, 1, 0)
	touchFrame.BackgroundTransparency = 1
	touchFrame.Parent = screenGui
	touchFrame.Visible = false

	local function makeTouchButton(name, label, size, pos, anchor, color, action)
		local btn = Instance.new("TextButton")
		btn.Name = name
		btn.Size = size
		btn.Position = pos
		btn.AnchorPoint = anchor or Vector2.new(0, 0)
		btn.BackgroundColor3 = color or Color3.fromRGB(80, 80, 80)
		btn.BackgroundTransparency = 0.4
		btn.Text = label
		btn.TextColor3 = COLOR_WHITE
		btn.TextSize = 18
		btn.Font = Enum.Font.GothamBold
		btn.TextStrokeTransparency = 0.5
		btn.Parent = touchFrame
		btn.Active = true

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 12)
		corner.Parent = btn

		local stroke = Instance.new("UIStroke")
		stroke.Color = COLOR_WHITE
		stroke.Thickness = 1.5
		stroke.Transparency = 0.5
		stroke.Parent = btn

		btn.MouseButton1Down:Connect(function()
			touchInput[action] = true
			btn.BackgroundTransparency = 0.1
		end)
		btn.MouseButton1Up:Connect(function()
			touchInput[action] = false
			btn.BackgroundTransparency = 0.4
		end)

		btn.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch then
				touchInput[action] = true
				btn.BackgroundTransparency = 0.1
			end
		end)
		btn.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch then
				touchInput[action] = false
				btn.BackgroundTransparency = 0.4
			end
		end)

		return btn
	end

	local btnSize = UDim2.new(0, 65, 0, 65)
	local dpadY = 0.72

	-- D-PAD (bottom left)
	makeTouchButton("Left", "<", btnSize,
		UDim2.new(0, 15, dpadY, 0), Vector2.new(0, 0),
		Color3.fromRGB(70, 70, 90), "left")

	makeTouchButton("Right", ">", btnSize,
		UDim2.new(0, 145, dpadY, 0), Vector2.new(0, 0),
		Color3.fromRGB(70, 70, 90), "right")

	makeTouchButton("Jump", "JUMP", UDim2.new(0, 130, 0, 50),
		UDim2.new(0, 15, dpadY, -58), Vector2.new(0, 0),
		Color3.fromRGB(70, 90, 70), "jump")

	makeTouchButton("Block", "BLOCK", UDim2.new(0, 130, 0, 50),
		UDim2.new(0, 15, dpadY, 72), Vector2.new(0, 0),
		Color3.fromRGB(90, 90, 50), "block")

	-- ATTACK BUTTONS (bottom right)
	local atkBtnSize = UDim2.new(0, 75, 0, 75)

	makeTouchButton("Punch", "PUNCH", atkBtnSize,
		UDim2.new(1, -165, dpadY, -20), Vector2.new(0, 0),
		Color3.fromRGB(180, 60, 60), "punch")

	makeTouchButton("Kick", "KICK", atkBtnSize,
		UDim2.new(1, -80, dpadY, -20), Vector2.new(0, 0),
		Color3.fromRGB(60, 100, 180), "kick")

	makeTouchButton("Special", "SPECIAL", UDim2.new(0, 160, 0, 50),
		UDim2.new(1, -165, dpadY, 62), Vector2.new(0, 0),
		Color3.fromRGB(160, 120, 30), "special")

	-- ABILITY BUTTONS (above attack buttons)
	makeTouchButton("Ability1", "ABIL 1", UDim2.new(0, 75, 0, 50),
		UDim2.new(1, -165, dpadY, -78), Vector2.new(0, 0),
		Color3.fromRGB(200, 100, 30), "ability1")

	makeTouchButton("Ability2", "ABIL 2", UDim2.new(0, 75, 0, 50),
		UDim2.new(1, -80, dpadY, -78), Vector2.new(0, 0),
		Color3.fromRGB(30, 120, 200), "ability2")
end

-- ============================================================
-- MESSAGE SYSTEM
-- ============================================================
local messageClear = nil

local function showMessage(text, color, duration, sub)
	centerLabel.Text = text
	centerLabel.TextColor3 = color or COLOR_WHITE
	centerLabel.TextSize = 48
	subLabel.Text = sub or ""

	centerLabel.TextTransparency = 1
	TweenService:Create(centerLabel, TweenInfo.new(0.2), { TextTransparency = 0 }):Play()

	if sub then
		subLabel.TextTransparency = 1
		TweenService:Create(subLabel, TweenInfo.new(0.3), { TextTransparency = 0 }):Play()
	end

	if messageClear then task.cancel(messageClear) end
	messageClear = task.delay(duration or 2, function()
		TweenService:Create(centerLabel, TweenInfo.new(0.3), { TextTransparency = 1 }):Play()
		TweenService:Create(subLabel, TweenInfo.new(0.3), { TextTransparency = 1 }):Play()
	end)
end

-- ============================================================
-- HUD UPDATE
-- ============================================================
local function getHealthColor(ratio)
	if ratio > 0.5 then return COLOR_GREEN
	elseif ratio > 0.25 then return COLOR_YELLOW
	else return COLOR_RED end
end

local function updateHUD(state)
	if not state or not state.fighters or #state.fighters < 2 then return end

	local f1 = state.fighters[1]
	local f2 = state.fighters[2]

	p1NameLabel.Text = f1.name or "P1"
	p2NameLabel.Text = f2.name or "P2"

	local h1 = math.clamp(f1.health / Config.MAX_HEALTH, 0, 1)
	local h2 = math.clamp(f2.health / Config.MAX_HEALTH, 0, 1)

	p1BarFill.Size = UDim2.new(h1, 0, 1, 0)
	p1BarFill.BackgroundColor3 = getHealthColor(h1)
	p2BarFill.Size = UDim2.new(h2, 0, 1, 0)
	p2BarFill.BackgroundColor3 = getHealthColor(h2)

	timerLabel.Text = tostring(math.ceil(state.roundTimer or 60))
	timerLabel.TextColor3 = (state.roundTimer or 60) <= 10 and COLOR_RED or COLOR_WHITE

	roundLabel.Text = "ROUND " .. (state.currentRound or 1)

	for i, dot in ipairs(p1Dots) do
		dot.BackgroundColor3 = i <= (f1.roundWins or 0) and COLOR_GOLD or Color3.fromRGB(60,60,60)
	end
	for i, dot in ipairs(p2Dots) do
		dot.BackgroundColor3 = i <= (f2.roundWins or 0) and COLOR_GOLD or Color3.fromRGB(60,60,60)
	end
end

-- ============================================================
-- HELPER: show/hide lobby UI
-- ============================================================
local function showLobbyUI()
	lobbyBanner.Visible = true
	controlsHint.Visible = true
	tokenFrame.Visible = true
	equipOpenBtn.Visible = true
	controlsOpenBtn.Visible = true
	hudFrame.Visible = false
	botPopup.Visible = false
	queueIndicator.Visible = false
	shopPopup.Visible = false
	equipPanel.Visible = false
	controlsPanel.Visible = false
	abilityIndicatorFrame.Visible = false
	stopQueueAnimation()
	if touchFrame then touchFrame.Visible = false end
end

local function hideLobbyUI()
	lobbyBanner.Visible = false
	controlsHint.Visible = false
	botPopup.Visible = false
	queueIndicator.Visible = false
	shopPopup.Visible = false
	equipPanel.Visible = false
	equipOpenBtn.Visible = false
	controlsOpenBtn.Visible = false
	controlsPanel.Visible = false
	stopQueueAnimation()
end

-- ============================================================
-- EVENT HANDLERS
-- ============================================================
gameStateEvent.OnClientEvent:Connect(function(state)
	updateHUD(state)
	if state.phase == Config.Phases.COUNTDOWN then
		local t = math.ceil(state.phaseTimer or 0)
		if t > 0 then
			local prevText = centerLabel.Text
			centerLabel.Text = tostring(t)
			centerLabel.TextColor3 = COLOR_WHITE
			centerLabel.TextTransparency = 0
			subLabel.Text = "ROUND " .. (state.currentRound or 1)
			subLabel.TextTransparency = 0
			if prevText ~= tostring(t) then
				countdownBeep:Play()
			end
		end
	end
end)

gameEventEvent.OnClientEvent:Connect(function(eventType, data)
	if eventType == "enterLobby" then
		-- Player returned to lobby (or initial spawn)
		hideLobbyUI()
		showLobbyUI()
		playMenuMusic()

	elseif eventType == "enteredBotZone" then
		-- Player walked into VS BOT portal — show difficulty popup
		botPopup.Visible = true
		queueIndicator.Visible = false
		shopPopup.Visible = false
		equipPanel.Visible = false
		controlsPanel.Visible = false
		stopQueueAnimation()

	elseif eventType == "queued" then
		-- Player walked into VS FRIEND portal — show queue indicator
		botPopup.Visible = false
		shopPopup.Visible = false
		equipPanel.Visible = false
		controlsPanel.Visible = false
		queueIndicator.Visible = true
		startQueueAnimation()

	elseif eventType == "queueCancelled" then
		-- Player walked away from VS FRIEND zone
		queueIndicator.Visible = false
		stopQueueAnimation()

	elseif eventType == "enteredShopZone" then
		-- Player walked into SHOP portal — show shop popup
		botPopup.Visible = false
		queueIndicator.Visible = false
		equipPanel.Visible = false
		controlsPanel.Visible = false
		stopQueueAnimation()
		shopTokenLabel.Text = "Your Tokens: " .. tostring(myTokens)
		buildShopItems()
		shopPopup.Visible = true

	elseif eventType == "matchStart" then
		-- Entering a fight
		hideLobbyUI()
		tokenFrame.Visible = false
		hudFrame.Visible = true
		if touchFrame then touchFrame.Visible = true end
		-- Show ability indicators if player has equipped abilities
		local hasAbilities = updateAbilityIndicators()
		abilityIndicatorFrame.Visible = hasAbilities
		showMessage("VS " .. (data.opponentName or "???"), COLOR_WHITE, 2)
		playBattleMusic()

	elseif eventType == "fight" then
		showMessage("FIGHT!", COLOR_GOLD, 1.5)
		fightShout:Play()

	elseif eventType == "hit" then
		if data and data.attackType == "kick" then
			kickSound:Play()
		else
			punchSound:Play()
		end

	elseif eventType == "roundEnd" then
		showMessage("K.O.!", COLOR_RED, 2.5)
		koSound:Play()

	elseif eventType == "newRound" then
		showMessage("ROUND " .. (data.round or "?"), COLOR_WHITE, 1.5, "GET READY")

	elseif eventType == "matchEnd" then
		local color = data.winnerName == player.Name and COLOR_GOLD or COLOR_RED
		showMessage(data.winnerName .. " WINS!", color, 4, "Match Over")
		stopAllMusic()
		winSound:Play()
		abilityIndicatorFrame.Visible = false
		-- Just hide fight UI; server will send "enterLobby" after teleport
		task.delay(4, function()
			hudFrame.Visible = false
			if touchFrame then touchFrame.Visible = false end
		end)

	elseif eventType == "opponentLeft" then
		showMessage("OPPONENT LEFT", COLOR_YELLOW, 2)

	elseif eventType == "tokenUpdate" then
		-- Server synced token count
		myTokens = data.tokens or 0
		updateTokenDisplay()
		if shopPopup.Visible then
			shopTokenLabel.Text = "Your Tokens: " .. tostring(myTokens)
			buildShopItems()
		end

	elseif eventType == "inventoryUpdate" then
		-- Server synced inventory and equipped abilities
		myInventory = data.inventory or {}
		myEquipped = { data.equipped1, data.equipped2 }
		updateAbilityIndicators()
		if equipPanel.Visible then
			buildEquipList()
		end
		if shopPopup.Visible then
			buildShopItems()
		end

	elseif eventType == "tokenReward" then
		-- Floating "+X tokens!" after winning a bot fight
		local amount = data.amount or 0
		if amount > 0 then
			showTokenReward(amount)
		end

	elseif eventType == "shopResult" then
		-- Purchase feedback
		local success = data.success or false
		local msg = data.message or ""
		showShopResult(success, msg)
		-- Rebuild shop items after purchase
		if shopPopup.Visible then
			task.delay(0.2, function()
				buildShopItems()
			end)
		end
	end
end)

-- ============================================================
-- INITIAL STATE — lobby banner visible, everything else hidden
-- ============================================================
lobbyBanner.Visible = true
controlsHint.Visible = true
tokenFrame.Visible = true
equipOpenBtn.Visible = true
controlsOpenBtn.Visible = true
hudFrame.Visible = false
botPopup.Visible = false
queueIndicator.Visible = false
shopPopup.Visible = false
equipPanel.Visible = false
controlsPanel.Visible = false
abilityIndicatorFrame.Visible = false
if touchFrame then touchFrame.Visible = false end
centerLabel.TextTransparency = 1
subLabel.TextTransparency = 1

print("[PixelBrawl] HUD loaded! Mobile controls: " .. tostring(isMobile))
]]></ProtectedString>
        </Properties>
      </Item>
  </Item>
  <Item class="StarterPack" referent="RBXF4A234DB">
    <Properties>
      <string name="Name">StarterPack</string>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="RBXF4A234DC">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="RBXF4A234DC1">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="RBX00000067">
        <Properties>
          <string name="Name">FightClient</string>
          <ProtectedString name="Source"><![CDATA[--[[
	FightClient - Client-side input, camera, and effects for Pixel Brawl
	LOCATION: StarterPlayer > StarterPlayerScripts > FightClient (LocalScript)

	Supports keyboard AND mobile touch input!
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Config = require(ReplicatedStorage:WaitForChild("FightConfig"))
local remotesFolder = ReplicatedStorage:WaitForChild("FightRemotes")
local sendInputEvent = remotesFolder:WaitForChild(Config.Remotes.SEND_INPUT)
local gameStateEvent = remotesFolder:WaitForChild(Config.Remotes.GAME_STATE)
local gameEventEvent = remotesFolder:WaitForChild(Config.Remotes.GAME_EVENT)

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- ============================================================
-- STATE
-- ============================================================
local inMatch = false
local inLobby = true
local myIndex = 0
local opponentName = ""
local currentState = nil
local screenShake = 0
local shakeDecay = 0.85

-- Detect mobile
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- ============================================================
-- INPUT STATE (shared between keyboard and touch)
-- ============================================================
local keysHeld = {
	left = false, right = false, jump = false,
	block = false, punch = false, kick = false, special = false,
	ability1 = false, ability2 = false,
}

local InputState = {}
InputState.keysHeld = keysHeld
InputState.isMobile = isMobile

local inputModule = Instance.new("BindableEvent")
inputModule.Name = "FightInputBridge"
inputModule.Parent = player:WaitForChild("PlayerGui")

-- ============================================================
-- KEYBOARD INPUT
-- ============================================================
local keyMap = {
	[Enum.KeyCode.A] = "left",
	[Enum.KeyCode.Left] = "left",
	[Enum.KeyCode.D] = "right",
	[Enum.KeyCode.Right] = "right",
	[Enum.KeyCode.W] = "jump",
	[Enum.KeyCode.Up] = "jump",
	[Enum.KeyCode.Space] = "jump",
	[Enum.KeyCode.S] = "block",
	[Enum.KeyCode.Down] = "block",
	[Enum.KeyCode.F] = "punch",
	[Enum.KeyCode.Q] = "punch",
	[Enum.KeyCode.G] = "kick",
	[Enum.KeyCode.E] = "kick",
	[Enum.KeyCode.H] = "special",
	[Enum.KeyCode.R] = "special",
	[Enum.KeyCode.Z] = "ability1",
	[Enum.KeyCode.One] = "ability1",
	[Enum.KeyCode.X] = "ability2",
	[Enum.KeyCode.Two] = "ability2",
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	local action = keyMap[input.KeyCode]
	if action then keysHeld[action] = true end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
	local action = keyMap[input.KeyCode]
	if action then keysHeld[action] = false end
end)

-- Send input to server (only during matches, keyboard only — mobile handled by FightHUD)
RunService.Heartbeat:Connect(function()
	if inMatch and not isMobile then
		sendInputEvent:FireServer(keysHeld)
	end
end)

-- ============================================================
-- CAMERA - LOBBY (normal Roblox) / FIGHT (close side view)
-- ============================================================
local CAMERA_Z_OFFSET = 25
local CAMERA_Y_BASE = 6
local cameraSmooth = Vector3.new(0, CAMERA_Y_BASE, CAMERA_Z_OFFSET)

local function updateCamera()
	-- In lobby: use normal Roblox 3rd-person camera
	if inLobby then
		camera.CameraType = Enum.CameraType.Custom
		return
	end

	-- In match: use scriptable fight camera
	camera.CameraType = Enum.CameraType.Scriptable

	if currentState and currentState.fighters and #currentState.fighters >= 2 then
		local f1 = currentState.fighters[1]
		local f2 = currentState.fighters[2]
		local midX = (f1.x + f2.x) / 2
		local midY = math.max((f1.y + f2.y) / 2 + 4, CAMERA_Y_BASE)

		local dist = math.abs(f1.x - f2.x)
		local zoomZ = math.clamp(dist * 0.6 + 12, 16, 40)

		local targetPos = Vector3.new(midX, midY, zoomZ)
		cameraSmooth = cameraSmooth:Lerp(targetPos, 0.08)

		local shakeX, shakeY = 0, 0
		if screenShake > 0.5 then
			shakeX = (math.random() - 0.5) * screenShake * 0.4
			shakeY = (math.random() - 0.5) * screenShake * 0.4
			screenShake = screenShake * shakeDecay
		else
			screenShake = 0
		end

		local finalPos = cameraSmooth + Vector3.new(shakeX, shakeY, 0)
		local lookAt = Vector3.new(midX + shakeX, midY + shakeY - 1, 0)
		camera.CFrame = CFrame.new(finalPos, lookAt)
	else
		camera.CFrame = CFrame.new(Vector3.new(0, 12, 40), Vector3.new(0, 8, 0))
	end
end

RunService.RenderStepped:Connect(updateCamera)

-- ============================================================
-- EFFECTS
-- ============================================================
local function createHitEffect(position, color, count)
	for i = 1, (count or 6) do
		local part = Instance.new("Part")
		part.Size = Vector3.new(0.4, 0.4, 0.4)
		part.Position = Vector3.new(position.x or 0, (position.y or 3) + 3, 0)
		part.Anchored = false
		part.CanCollide = false
		part.Material = Enum.Material.Neon
		part.BrickColor = BrickColor.new(color or "Bright yellow")
		part.Parent = workspace

		local velocity = Instance.new("BodyVelocity")
		velocity.Velocity = Vector3.new(
			(math.random() - 0.5) * 30,
			math.random() * 20 + 10,
			(math.random() - 0.5) * 5
		)
		velocity.MaxForce = Vector3.new(1000, 1000, 1000)
		velocity.Parent = part

		game:GetService("Debris"):AddItem(part, 0.5)
		game:GetService("Debris"):AddItem(velocity, 0.15)
	end
end

local function createProjectileEffect(data)
	-- Determine projectile properties from ability data
	local speed = 60
	local lifetime = 2
	local coreColor = Color3.fromRGB(255, 200, 50)   -- bright yellow-orange core
	local glowColor = Color3.fromRGB(255, 80, 20)     -- deep orange-red glow
	local trailColor = Color3.fromRGB(255, 60, 10)    -- red-orange trail

	if data.abilityKey and Config.AbilityAttacks[data.abilityKey] then
		local atkData = Config.AbilityAttacks[data.abilityKey]
		speed = atkData.projectileSpeed or speed
		lifetime = atkData.projectileLifetime or lifetime
		if Config.ShopAbilities[data.abilityKey] then
			local c = Config.ShopAbilities[data.abilityKey].color
			glowColor = c
		end
	end

	-- Main fireball core (bright inner sphere)
	local core = Instance.new("Part")
	core.Name = "FireballCore"
	core.Size = Vector3.new(1.8, 1.8, 1.8)
	core.Position = Vector3.new(data.x, data.y + 3, 0)
	core.Anchored = false
	core.CanCollide = false
	core.Material = Enum.Material.Neon
	core.Shape = Enum.PartType.Ball
	core.Color = coreColor
	core.Transparency = 0
	core.Parent = workspace

	-- Outer glow shell (slightly larger, semi-transparent)
	local glow = Instance.new("Part")
	glow.Name = "FireballGlow"
	glow.Size = Vector3.new(3.0, 3.0, 3.0)
	glow.Anchored = false
	glow.CanCollide = false
	glow.Material = Enum.Material.Neon
	glow.Shape = Enum.PartType.Ball
	glow.Color = glowColor
	glow.Transparency = 0.5
	glow.Parent = workspace

	-- Weld glow to core so they move together
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = core
	weld.Part1 = glow
	weld.Parent = core

	-- Velocity on core (glow follows via weld)
	local vel = Instance.new("BodyVelocity")
	vel.Velocity = Vector3.new(data.dir * speed, 0, 0)
	vel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	vel.Parent = core

	-- Bright point light for fire glow
	local light = Instance.new("PointLight")
	light.Color = glowColor
	light.Range = 18
	light.Brightness = 3
	light.Parent = core

	-- Fire particle emitter (trailing flames)
	local fireEmitter = Instance.new("ParticleEmitter")
	fireEmitter.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, coreColor),
		ColorSequenceKeypoint.new(0.3, glowColor),
		ColorSequenceKeypoint.new(1, trailColor),
	})
	fireEmitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 2.0),
		NumberSequenceKeypoint.new(0.5, 1.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	fireEmitter.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(0.5, 0.5),
		NumberSequenceKeypoint.new(1, 1),
	})
	fireEmitter.Lifetime = NumberRange.new(0.15, 0.35)
	fireEmitter.Rate = 120
	fireEmitter.Speed = NumberRange.new(2, 8)
	fireEmitter.SpreadAngle = Vector2.new(25, 25)
	fireEmitter.RotSpeed = NumberRange.new(-200, 200)
	fireEmitter.LightEmission = 1
	fireEmitter.LightInfluence = 0
	fireEmitter.Parent = core

	-- Smoke trail behind fireball
	local smokeEmitter = Instance.new("ParticleEmitter")
	smokeEmitter.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 40, 10)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 30, 30)),
	})
	smokeEmitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.8),
		NumberSequenceKeypoint.new(1, 2.5),
	})
	smokeEmitter.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(1, 1),
	})
	smokeEmitter.Lifetime = NumberRange.new(0.3, 0.6)
	smokeEmitter.Rate = 60
	smokeEmitter.Speed = NumberRange.new(1, 4)
	smokeEmitter.SpreadAngle = Vector2.new(40, 40)
	smokeEmitter.LightEmission = 0.3
	smokeEmitter.Parent = core

	-- Flickering light effect (animate brightness/color)
	task.spawn(function()
		local startTick = tick()
		while core and core.Parent and (tick() - startTick) < lifetime do
			local flicker = 0.7 + math.random() * 0.6
			light.Brightness = 2.5 * flicker
			light.Range = 14 + math.random() * 8
			glow.Transparency = 0.4 + math.random() * 0.2
			core.Size = Vector3.new(1.6 + math.random() * 0.4, 1.6 + math.random() * 0.4, 1.6 + math.random() * 0.4)
			task.wait(0.04)
		end
	end)

	game:GetService("Debris"):AddItem(core, lifetime)
	game:GetService("Debris"):AddItem(glow, lifetime)
end

-- ============================================================
-- SOUND EFFECTS
-- ============================================================
local function createSound(name, volume, pitch)
	local sound = Instance.new("Sound")
	sound.Name = name
	sound.Volume = volume or 0.5
	if pitch then sound.PlaybackSpeed = pitch end
	sound.Parent = player:WaitForChild("PlayerGui")
	return sound
end

local punchSound = createSound("Punch", 0.3, 1.5)
local kickSound = createSound("Kick", 0.4, 0.8)
local hitSound = createSound("Hit", 0.5, 1.0)
local blockSound = createSound("Block", 0.3, 2.0)

-- ============================================================
-- HELPER: enable/disable Roblox controls
-- ============================================================
local function setRobloxControls(enabled)
	local playerModule = player:WaitForChild("PlayerScripts"):FindFirstChild("PlayerModule")
	if playerModule then
		local controls = require(playerModule):GetControls()
		if enabled then controls:Enable() else controls:Disable() end
	end
end

-- ============================================================
-- GAME EVENT HANDLER
-- ============================================================
gameEventEvent.OnClientEvent:Connect(function(eventType, data)
	if eventType == "enterLobby" then
		inMatch = false
		inLobby = true
		currentState = nil
		camera.CameraType = Enum.CameraType.Custom
		setRobloxControls(true)

	elseif eventType == "matchStart" then
		inMatch = true
		inLobby = false
		myIndex = data.playerIndex
		opponentName = data.opponentName
		setRobloxControls(false)

	elseif eventType == "attack" then
		if data.attackType == "punch" then punchSound:Play()
		elseif data.attackType == "kick" then kickSound:Play() end

	elseif eventType == "hit" then
		hitSound:Play()
		screenShake = 6
		createHitEffect(data, "Bright yellow", 8)

	elseif eventType == "blocked" then
		blockSound:Play()
		screenShake = 2
		createHitEffect(data, "Bright blue", 4)

	elseif eventType == "projectile" then
		createProjectileEffect(data)

	elseif eventType == "roundEnd" then
		screenShake = 10

	elseif eventType == "matchEnd" then
		screenShake = 15
		inMatch = false
		-- Don't set inLobby yet — wait for "enterLobby" from server after teleport
	end
end)

gameStateEvent.OnClientEvent:Connect(function(state)
	currentState = state
end)

-- Lock Z axis during fights only
RunService.Heartbeat:Connect(function()
	local char = player.Character
	if char and inMatch then
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp and math.abs(hrp.Position.Z) > 1 then
			hrp.CFrame = CFrame.new(hrp.Position.X, hrp.Position.Y, 0) * (hrp.CFrame - hrp.CFrame.Position)
		end
	end
end)

print("[PixelBrawl] Client loaded! Mobile: " .. tostring(isMobile))
]]></ProtectedString>
        </Properties>
      </Item>
    </Item>
    <Item class="StarterCharacterScripts" referent="RBXF4A234DC2">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
    </Item>
  </Item>
  <Item class="SoundService" referent="RBXF4A234DD">
    <Properties>
      <string name="Name">SoundService</string>
    </Properties>
  </Item>
  <Item class="Teams" referent="RBXF4A234DE">
    <Properties>
      <string name="Name">Teams</string>
    </Properties>
  </Item>
  <Item class="Chat" referent="RBXF4A234DF">
    <Properties>
      <string name="Name">Chat</string>
    </Properties>
  </Item>
  <Item class="LocalizationService" referent="RBXF4A234E0">
    <Properties>
      <string name="Name">LocalizationService</string>
    </Properties>
  </Item>
  <Item class="TestService" referent="RBXF4A234E1">
    <Properties>
      <string name="Name">TestService</string>
    </Properties>
  </Item>
</roblox>
